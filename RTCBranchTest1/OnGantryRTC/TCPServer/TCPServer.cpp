///////////////////////////////////////////////////////////////////////////////
// TCPServer.cpp
#include "TcPch.h"
#pragma hdrstop

#include "TCPServer.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CTCPServer
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CTCPServer
BEGIN_INTERFACE_MAP(CTCPServer)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
	INTERFACE_ENTRY(IID_ITcIoTcpProtocolRecv, ITcIoTcpProtocolRecv)
///</AutoGeneratedContent>
END_INTERFACE_MAP()

IMPLEMENT_ITCOMOBJECT(CTCPServer)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CTCPServer)
IMPLEMENT_ITCADI(CTCPServer)
IMPLEMENT_ITCWATCHSOURCE(CTCPServer)


///////////////////////////////////////////////////////////////////////////////
// Set parameters of CTCPServer 
BEGIN_SETOBJPARA_MAP(CTCPServer)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_TCPServerParameter, m_Parameter)
	SETOBJPARA_VALUE(PID_TCPServerTcpServerPort, m_TcpServerPort)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	SETOBJPARA_ITFPTR(PID_TCPServerTcpProt, m_spTcpProt)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CTCPServer 
BEGIN_GETOBJPARA_MAP(CTCPServer)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_TCPServerParameter, m_Parameter)
	GETOBJPARA_VALUE(PID_TCPServerTcpServerPort, m_TcpServerPort)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	GETOBJPARA_ITFPTR(PID_TCPServerTcpProt, m_spTcpProt)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CTCPServer
BEGIN_OBJPARAWATCH_MAP(CTCPServer)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CTCPServer
BEGIN_OBJDATAAREA_MAP(CTCPServer)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_TCPServerInputsModulator, m_InputsModulator)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsModulator, m_OutputsModulator)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsGun, m_InputsGun)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsGun, m_OutputsGun)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsWater, m_InputsWater)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsWater, m_OutputsWater)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsDose, m_InputsDose)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsDose, m_OutputsDose)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsAfc, m_InputsAfc)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsAfc, m_OutputsAfc)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsBeam, m_InputsBeam)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsBeam, m_OutputsBeam)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsVac, m_InputsVac)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsVac, m_OutputsVac)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsSF6, m_InputsSF6)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsSF6, m_OutputsSF6)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsPrf, m_InputsPrf)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsPrf, m_OutputsPrf)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsFsm, m_InputsFsm)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsFsm, m_OutputsFsm)
	OBJDATAAREA_VALUE(ADI_TCPServerPlanInputs, m_PlanInputs)
	OBJDATAAREA_VALUE(ADI_TCPServerPlanOutputs, m_PlanOutputs)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsHalState, m_InputsHalState)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsHalState, m_OutputsHalState)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsBsm, m_InputsBsm)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsBsm, m_OutputsBsm)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsVMAT, m_InputsVMAT)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsVMAT, m_OutputsVMAT)
	OBJDATAAREA_VALUE(ADI_TCPServerInputsIgs, m_InputsIgs)
	OBJDATAAREA_VALUE(ADI_TCPServerOutputsIgs, m_OutputsIgs)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CTCPServer::CTCPServer()
	: m_Trace(m_TraceLevelMax, m_spSrv)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	memset(&m_Parameter, 0, sizeof(m_Parameter));
	m_TcpServerPort = 0;
	memset(&m_InputsModulator, 0, sizeof(m_InputsModulator));
	memset(&m_OutputsModulator, 0, sizeof(m_OutputsModulator));
	memset(&m_InputsGun, 0, sizeof(m_InputsGun));
	memset(&m_OutputsGun, 0, sizeof(m_OutputsGun));
	memset(&m_InputsWater, 0, sizeof(m_InputsWater));
	memset(&m_OutputsWater, 0, sizeof(m_OutputsWater));
	memset(&m_InputsDose, 0, sizeof(m_InputsDose));
	memset(&m_OutputsDose, 0, sizeof(m_OutputsDose));
	memset(&m_InputsAfc, 0, sizeof(m_InputsAfc));
	memset(&m_OutputsAfc, 0, sizeof(m_OutputsAfc));
	memset(&m_InputsBeam, 0, sizeof(m_InputsBeam));
	memset(&m_OutputsBeam, 0, sizeof(m_OutputsBeam));
	memset(&m_InputsVac, 0, sizeof(m_InputsVac));
	memset(&m_OutputsVac, 0, sizeof(m_OutputsVac));
	memset(&m_InputsSF6, 0, sizeof(m_InputsSF6));
	memset(&m_OutputsSF6, 0, sizeof(m_OutputsSF6));
	memset(&m_InputsPrf, 0, sizeof(m_InputsPrf));
	memset(&m_OutputsPrf, 0, sizeof(m_OutputsPrf));
	memset(&m_InputsFsm, 0, sizeof(m_InputsFsm));
	memset(&m_OutputsFsm, 0, sizeof(m_OutputsFsm));
	memset(&m_PlanInputs, 0, sizeof(m_PlanInputs));
	memset(&m_PlanOutputs, 0, sizeof(m_PlanOutputs));
	memset(&m_InputsHalState, 0, sizeof(m_InputsHalState));
	memset(&m_OutputsHalState, 0, sizeof(m_OutputsHalState));
	memset(&m_InputsBsm, 0, sizeof(m_InputsBsm));
	memset(&m_OutputsBsm, 0, sizeof(m_OutputsBsm));
	memset(&m_InputsVMAT, 0, sizeof(m_InputsVMAT));
	memset(&m_OutputsVMAT, 0, sizeof(m_OutputsVMAT));
	memset(&m_InputsIgs, 0, sizeof(m_InputsIgs));
	memset(&m_OutputsIgs, 0, sizeof(m_OutputsIgs));
///</AutoGeneratedContent>
	m_SockId = 0;
	/* ==Customer Add============================================================ */
	ClientSocket = 0;
	SequenceNum = 1;
	memset(SendBuffer, 0, sizeof(SendBuffer));
	memset(RecvBuffer, 0, sizeof(RecvBuffer));
	memset(DequeueBuf, 0, sizeof(DequeueBuf));
	memset(&IntlIndicator, 0, sizeof(IntlIndicator));
	memset(&m_PlanExceptionCtrl, 0, sizeof(m_PlanExceptionCtrl));
	SendBufferCursor = 0;
	CycleCounter = 0;
	CurrentSysTime = 0;
	m_IgsExpListGroup = 0;
	m_AutoResetCounter = 0;

	/* ==End===================================================================== */
}

///////////////////////////////////////////////////////////////////////////////
CTCPServer::~CTCPServer() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CTCPServer)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CTCPServer::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	// TODO: Add initialization code

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CTCPServer::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	if (SUCCEEDED(hr) && m_spTcpProt.HasOID())
	{
		hr = m_spSrv->TcQuerySmartObjectInterface(m_spTcpProt);
	}


	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CTCPServer::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	RemoveModuleFromCaller(); 

	if (m_SockId != 0)
	{
		if (m_spTcpProt->IsConnected(m_SockId))
		{
			m_spTcpProt->Close(m_SockId);
			m_spTcpProt->CheckReceived();
		}

		m_spTcpProt->FreeSocket(m_SockId);
		m_SockId = 0;
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CTCPServer::SetObjStateSP()
{
	HRESULT hr = S_OK;
	m_Trace.Log(tlVerbose, FENTERA);

	// TODO: Add deinitialization code

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CTCPServer::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	/*Delay for Tcp port listen*/
	if (m_DelayListenTimer.IsReady())
	{
		GetCurSysTime(ipTask);
		m_DelayListenTimer.StartTimer(CurrentSysTime, DELAY_LISTEN_TIME);
		return hr;
	}
	else if (!m_DelayListenTimer.IsTimeOut(CurrentSysTime))
	{
		GetCurSysTime(ipTask);
		return hr; //wait
	}
	else
	{
		//cotinue run
	}

	/*check tcp recevie data*/
	m_spTcpProt->CheckReceived();
	
	/*get current system time*/
	GetCurSysTime(ipTask);
	
	/*auto reset gui command*/
	ResetModuleOutput();

	/*wait client connect*/
	if (FALSE == ListenSocket())
	{
		return hr;	//new cycle
	}

	/*reponse tcp request*/
	ResponseRequest();
	
	/*if (m_InputsFsm.CurrentState == 6)
	{
		m_Trace.Log(tlInfo, "Line:%d:: RadiationIndex = %d CurrentDoseTotal = %f", __LINE__, m_InputsFsm.RadiationIndex, m_InputsBeam.beam_total_read1);
	}*/
	return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT CTCPServer::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CTCPServer::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;

	m_Trace.Log(tlVerbose, FLEAVEA);
}


///<AutoGeneratedContent id="ImplementationOf_ITcIoTcpProtocolRecv">
HRESULT CTCPServer::ReceiveData(ULONG socketId, ULONG nData, PVOID pData)
{
#if 0
	HRESULT hr = S_OK;

    memset(&m_response, 0, 100);
    int endpos = min(100, nData);
    memcpy(&m_response, pData, endpos);
    m_response[endpos] = 0; //\0 term
    m_Trace.Log(tlInfo, FLEAVEA "Receive answer w/ length %d : first 100 chars:'%.100s'", nData, m_response);
	m_spTcpProt->SendData(socketId, endpos, m_response, nSentData); 
	return hr; 
#endif

	HRESULT hr = S_OK;
	BOOL ret = FALSE;
	UCHAR *temp_pointer = (UCHAR *)pData;
	USHORT temp_len = 0;

	/* check input parameter pData */
	if (pData == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line%d::<ReceiveData>:: pData is NULL", __LINE__);
		#endif

		return hr;
	}
	/* check input parameter nData*/
	if (nData >= MC_COM_RECV_MAX_SIZE)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line%d::<ReceiveData>:: nData is beyond 1024", __LINE__);
		#endif

		return hr;	//drop message package
	}

	/*store data into queue*/
	UCHAR * temp = (UCHAR *)pData;
	if (temp[4] == MC_WRITE_REQUEST)
	{
		Spinlock.Lock();//into critical area
		ret = WriteQueue.Enqueue((UCHAR *)pData, (UINT16)nData);	//store receive data into queue
		Spinlock.Unlock();//out critical area
	}
	else if (temp[4] == MC_READ_REQUEST)
	{
		Spinlock.Lock();//into critical area
		ret = CycleQueue.Enqueue((UCHAR *)pData, (UINT16)nData);	//store receive data into queue
		Spinlock.Unlock();//out critical area
	}
	else
	{
		//do nothing
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line%d::<ReceiveData>:: Invaild request type", __LINE__);
		#endif

		return hr;	//drop message package 
	}


	if (QUEUE_FAIL == ret)											//judge operation success
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line%d::<ReceiveData>:: Enqueue failed", __LINE__);
		#endif

		return hr;
	}
	else
	{
		/*new cycle*/
		#if MC_COM_DEBUG_RECV_DATA
			m_Trace.Log(tlInfo, "<ReceiveData>:: Enqueue success>>>%d bytes", nData);
		#endif

		return hr;
	}
}

HRESULT CTCPServer::ReceiveEvent(ULONG socketId, TCPIP_EVENT tcpEvent)
{
	//#if MC_COM_DEBUG_RECV_EVENT
		//m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d", socketId, tcpEvent);
	//#endif
	switch (tcpEvent)
	{
		case TCPIP_EVENT_RESET:
			m_spTcpProt->FreeSocket(socketId);		//free socket
			m_spTcpProt->Close(socketId);			//close socket
			
			m_SockId = 0;
			ClientSocket = 0;						//reset socket

			#if MC_COM_DEBUG_RECV_EVENT
			m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Reset Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_TIMEOUT:
			/*if (socketId == m_SockId)
			{
				#if MC_COM_DEBUG_RECV_EVENT
					m_Trace.Log(tlInfo, FLEAVEA "Connection failed!");
				#endif
			}*/
			m_spTcpProt->FreeSocket(socketId);		//free socket
			m_spTcpProt->Close(socketId);			//close socket
			
			m_SockId = 0;							//+++
			ClientSocket = 0;						//reset socket

			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Timeout Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_CONN_CLOSED:
			m_spTcpProt->FreeSocket(socketId);		//free socket
			m_spTcpProt->Close(socketId);			//close socket
			
			m_SockId = 0;							//+++
			ClientSocket = 0;						//reset socket

			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Close Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_CONN_INCOMING:
			m_spTcpProt->Accept(socketId);			//server
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Connect incoming Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_CONN_ESTABLISHED:
			ClientSocket = socketId;				//assign socket for client
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Established Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_KEEP_ALIVE:
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:KeepAlive Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_CONN_IDLE:
			//m_spTcpProt->FreeSocket(socketId);
			//m_SockId = 0;
			//ClientSocket = 0;	//reset socket
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Idle Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_DATA_SENT:
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Sent Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_DATA_RECEIVED:
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Receive Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_LINKCONNECT:
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Linkconnect Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_LINKDISCONNECT:
			m_spTcpProt->Close(socketId);			//++++
			m_spTcpProt->FreeSocket(socketId);

			m_SockId = 0;
			ClientSocket = 0;	//reset socket

			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:LinkDisconnect Event", socketId, tcpEvent);
			#endif
			break;
		case TCPIP_EVENT_ERROR:
			m_spTcpProt->FreeSocket(socketId);		//free socket
			m_spTcpProt->Close(socketId);			//close socket

			m_SockId = 0;
			ClientSocket = 0;						//reset socket
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Error Event", socketId, tcpEvent);
			#endif
			break;
		default:
			#if MC_COM_DEBUG_RECV_EVENT
				m_Trace.Log(tlInfo, FLEAVEA "Receive TCP Event: SocketId: %d Event: %d:Unknow Event", socketId, tcpEvent);
			#endif
			break;
	}

	return S_OK;
}
///</AutoGeneratedContent>

/******************************************************************************
* Function: PackageHeader(PackageHead_s PackageHead, UCHAR *SendBuf, UINT16 *const Postion)
*
* Describe: 
*
* Input   : struct package_head_s package_head, UCHAR *sendbuf, UINT16 *postion
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageHeader(PackageHead_s PackageHead, UCHAR *SendBuf, UINT16 *const Postion)
{
	/*input parameters availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_header>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*input parameters correctness check*/
	if (MC_COM_PACKAGE_START_POS != *Postion)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_header>::parameter postion is error", __LINE__);
		#endif

		return FALSE;
	}
	
	/*package header data into sendbuf*/
	SendBuf[(*Postion)++] = PackageHead.SequenceNum.uint16_byte.high_byte;	//uint16 high byte
	SendBuf[(*Postion)++] = PackageHead.SequenceNum.uint16_byte.low_byte;	//uint16 low byte
	SendBuf[(*Postion)++] = PackageHead.SenderID;
	SendBuf[(*Postion)++] = PackageHead.ReceiverID;
	SendBuf[(*Postion)++] = PackageHead.RequestType;

	return TRUE;
}

/******************************************************************************
* Function: PackageBody(UCHAR DataUnit, UCHAR *SendBuf, UINT16 *Postion)
*
* Describe: package body with data unit identifer
*
* Input   : UCHAR data_unit, UCHAR *sendbuf, UINT16 *postion
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBody(UCHAR DataUnit, UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body into sendbuf*/
	switch (DataUnit)
	{
		case MC_UNIT_ID_MODULATOR:
		{
			if (FALSE == PackageBodyModulator(SendBuf, Postion))	//package modulator data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body modulator failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_GUN:
		{
			if (FALSE == PackageBodyGun(SendBuf, Postion))	//package gun data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body gun failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_COOLING:
		{
			if (FALSE == PackageBodyWater(SendBuf, Postion))	//package water data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body water failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_AFC:
		{
			if (FALSE == PackageBodyAfc(SendBuf, Postion))	//package afc data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body afc failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_BEAM:
		{
			if (FALSE == PackageBodyBeam(SendBuf, Postion))	//package beam data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body dose failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_INTERLOCK:
		{
			if (FALSE == PackageBodyInterlock(SendBuf, Postion))	//package interlock data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body interlock failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_SYS_STATUS:
		{
			if (FALSE == PackageBodySysStatus(SendBuf, Postion))	//package system status data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body system status failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_UNREADY:
		{
			if (FALSE == PackageBodyUnready(SendBuf, Postion))	//package unready data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body unready failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_GEOMETRY:
		{
			if (FALSE == PackageBodyGeometry(SendBuf, Postion))	//package geometry data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body geometry failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_EVENT:
		{
			if (FALSE == PackageBodyEvent(SendBuf, Postion))	//package event data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body event failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_CTRL_STATE:
		{
			if (FALSE == PackageBodyCtrlState(SendBuf, Postion))	//package controller state data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body couch failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_BSM:
		{
			if (FALSE == PackageBodyBsm(SendBuf, Postion))	//package Bsm data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body bsm failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_DOSE:
		{
			if (FALSE == PackageBodyDose(SendBuf, Postion))	//package dose data into sendbuf
			{
				#if MC_COM_DEBUG_EXP_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body dose failed:%d", __LINE__);
				#endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_IGS:
		{
			if (FALSE == PackageBodyIgs(SendBuf, Postion))	//package dose data into sendbuf
			{
                #if MC_COM_DEBUG_EXP_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body dose failed:%d", __LINE__);
                #endif

				return FALSE;
			}
			break;
		}
		case MC_UNIT_ID_IGSICU:
		{
			if (FALSE == PackageBodyIgsIcu(SendBuf, Postion))	//package dose data into sendbuf
			{
              #if MC_COM_DEBUG_EXP_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body dose failed:%d", __LINE__);
              #endif

				return FALSE;
			}
			break;
		}
		
		case MC_UNIT_ID_IGSEXPOSE_GANTRY_LIST:
		{
			if (FALSE == PackageBodyIgsExposeGantryList(SendBuf, Postion))	//package dose data into sendbuf
			{
               #if MC_COM_DEBUG_EXP_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::package body dose failed:%d", __LINE__);
                #endif

				return FALSE;
			}
			break;
		}
		default:	//error
		{
			#if MC_COM_DEBUG_EXP_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_package_body>::invaild parameter:%d", __LINE__, DataUnit);
			#endif

			return FALSE;
		}	
	}

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyModulator(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe: package modulator data into sendbuf
*
* Input   : 
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyModulator(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_modulator>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_modulator>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	/*package data struct TCLV--data T*/
	SendBuf[(*Postion)++] = MC_UNIT_ID_MODULATOR;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	/*package data struct TCLV--data L*/
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_MODULATOR_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_MODULATOR_LEN;

	/*package data struct TLV--data V*/
	UINT16 temp_uint16_array[2] = { 0 };
	temp_uint16_array[0] = m_InputsModulator.mod_state_set_read;	//load data
	temp_uint16_array[1] = m_InputsModulator.mod_state_read;
	ConvertModubsFormat(temp_uint16_array, SendBuf, Postion, 2);	//package two uint16 value into send buffer
	
	FLOAT temp_float_array[9] = { 0 };
	temp_float_array[0] = m_InputsModulator.mod_filament_vol_set_read;	//load data
	temp_float_array[1] = m_InputsModulator.mod_filament_vol_read;
	temp_float_array[2] = m_InputsModulator.mod_filament_current_read;
	temp_float_array[3] = m_InputsModulator.mod_dc_voltage_set_read;
	temp_float_array[4] = m_InputsModulator.mod_dc_vol_read;
	temp_float_array[5] = m_InputsModulator.mod_pulse_width_set_read;
	temp_float_array[6] = m_InputsModulator.mod_pulse_width_read;
	temp_float_array[7] = m_InputsModulator.mod_average_power_read;
	temp_float_array[8] = m_InputsModulator.mod_prf_read;
	ConvertModubsFormat(temp_float_array, SendBuf, Postion, 9);	//package nine float value into send buffer

	UINT32 temp_uint32_array[4] = { 0 };
	temp_uint32_array[0] = m_InputsModulator.mod_remaining_time;	//load data
	temp_uint32_array[1] = m_InputsModulator.mod_standby_interlock;
	temp_uint32_array[2] = m_InputsModulator.mod_hv_interlock;
	temp_uint32_array[3] = m_InputsModulator.mod_trig_interlock;
	ConvertModubsFormat(temp_uint32_array, SendBuf, Postion, 4);	//package four uint32 value into send buffer

	temp_uint16_array[0] = m_InputsModulator.mod_level;	//load data
	ConvertModubsFormat(temp_uint16_array, SendBuf, Postion, 1);	//package one uint16 value into send buffer

	temp_uint32_array[0] = m_InputsModulator.mod_off_hour;	//load data
	temp_uint32_array[1] = m_InputsModulator.mod_standby_hour;
	temp_uint32_array[2] = m_InputsModulator.mod_hv_hour;
	temp_uint32_array[3] = m_InputsModulator.mod_trig_hour;
	ConvertModubsFormat(temp_uint32_array, SendBuf, Postion, 4);	//package four uint32 value into send buffer

	temp_uint16_array[0] = m_InputsModulator.mod_app_ver;	//load data
	temp_uint16_array[1] = m_InputsModulator.mod_fpga_ver;
	ConvertModubsFormat(temp_uint16_array, SendBuf, Postion, 2);	//package two uint16 value into send buffer

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyWater(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyWater(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_water>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_water>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_COOLING;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_WATER_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_WATER_LEN;
	
	//package data struct TLV--data V
	UINT32 temp_uint32_array[1] = {0};
	temp_uint32_array[0] = m_InputsWater.water_flow_switch;
	ConvertModubsFormat(temp_uint32_array, SendBuf, Postion, 1);	//package 1 uint32 value into send buffer

	FLOAT temp_float_array[15] = { 0 };
	temp_float_array[0] = m_InputsWater.water_temp_1;
	temp_float_array[1] = m_InputsWater.water_temp_2;
	temp_float_array[2] = m_InputsWater.water_temp_3;
	temp_float_array[3] = m_InputsWater.water_temp_4;
	temp_float_array[4] = m_InputsWater.water_temp_5;
	temp_float_array[5] = m_InputsWater.water_flow_in;
	temp_float_array[6] = m_InputsWater.water_pressure;
	temp_float_array[7] = m_InputsWater.water_temp_in;
	temp_float_array[8] = m_InputsWater.water_temp_back;
	temp_float_array[9] = m_InputsWater.water_flow_low_set;
	temp_float_array[10] = m_InputsWater.water_temp_high_set;
	temp_float_array[11] = m_InputsWater.water_temp_low_set;
	temp_float_array[12] = m_InputsVac.vac_voltage;
	temp_float_array[13] = m_InputsVac.vac_current;
	temp_float_array[14] = m_InputsSF6.sf6_pressure;
	ConvertModubsFormat(temp_float_array, SendBuf, Postion, 15);	//package 12 float value into send buffer

	UINT16 temp_uint16_array[1] = { 0 };
	temp_uint16_array[0] = m_InputsWater.water_interlock_raw;
	ConvertModubsFormat(temp_uint16_array, SendBuf, Postion, 1);	//package 1 uint16 value into send buffer

	return TRUE;
}

/******************************************************************************
* Function:
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyGun(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_gun>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_gun>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_GUN;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_GUN_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_GUN_LEN;

	//package data struct TLV--data V
	FLOAT temp_float_array[4] = { 0 };
	temp_float_array[0] = m_InputsGun.gun_fila_vol_read;
	temp_float_array[1] = m_InputsGun.gun_hv_read;
	temp_float_array[2] = m_InputsGun.gun_fila_current_read;
	temp_float_array[3] = m_InputsGun.gun_cathode_current_read;
	ConvertModubsFormat(temp_float_array, SendBuf, Postion, 4);	//package three float value into send buffer

	SendBuf[(*Postion)++] = static_cast<BYTE>(m_InputsGun.GunRemainingTime>>8);	//fill high byte byte 
	SendBuf[(*Postion)++] = static_cast<BYTE>(m_InputsGun.GunRemainingTime);	//fill low byte byte

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyAfc(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyAfc(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_afc>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_afc>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_AFC;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_AFC_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_AFC_LEN;
	
	//package data struct TLV--data V
	UINT32 temp_uint32_array[1] = { 0 };
	temp_uint32_array[0] = m_InputsAfc.afc_mode;
	ConvertModubsFormat(temp_uint32_array, SendBuf, Postion, 1);	//package one uint32 value into send buffer

	FLOAT temp_float_array[2] = { 0 };
	temp_float_array[0] = m_InputsAfc.afc_current_pos;
	temp_float_array[1] = m_InputsAfc.afc_RF_AI;
	ConvertModubsFormat(temp_float_array, SendBuf, Postion, 2);	//package two float value into send buffer

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyBeam(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyBeam(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_dose>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_dose>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_BEAM;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_BEAM_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_BEAM_LEN;
	
	//package data struct TLV--data V
	FLOAT temp_float_array[2] = { 0 };
	temp_float_array[0] = m_InputsBeam.beam_total_read1;
	temp_float_array[1] = m_InputsBeam.beam_total_read2;
	ConvertModubsFormat(temp_float_array, SendBuf, Postion, 2);

	UINT32 temp_uint32_array[3] = { 0 };
	temp_uint32_array[0] = m_InputsBeam.beam_dose_rate_read1;
	temp_uint32_array[1] = m_InputsBeam.beam_dose_rate_read2;
	temp_uint32_array[2] = m_InputsBeam.beam_time_read;
	ConvertModubsFormat(temp_uint32_array, SendBuf, Postion, 3);	//package five uint32 value into send buffer

	uint16_union_t uint16_temp;
	uint16_temp.value = m_InputsFsm.RadiationIndex;
	SendBuf[(*Postion)++] = uint16_temp.uint16_byte.high_byte;	//fill 1 byte byte 
	SendBuf[(*Postion)++] = uint16_temp.uint16_byte.low_byte;	//fill 1 byte byte 

	temp_float_array[0] = m_InputsBeam.DoseDelta;
	ConvertModubsFormat(temp_float_array, SendBuf, Postion, 1);

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyInterlock(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyInterlock(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_interlock:: input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_interlock:: sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_INTERLOCK;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_INTERLOCK_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_INTERLOCK_LEN;

	//package data struct TLV--data V
	UINT32 TempUin32[5] = { 0 };
	TempUin32[0] = m_InputsFsm.Interlocks.BgmInterlock1;
	TempUin32[1] = m_InputsFsm.Interlocks.BgmInterlock2;
	TempUin32[2] = m_InputsFsm.Interlocks.IgsInterlock;
	TempUin32[3] = m_InputsFsm.Interlocks.BsmInterlock1;
	TempUin32[4] = m_InputsFsm.Interlocks.BsmInterlock2;
	ConvertModubsFormat(TempUin32, SendBuf, Postion, 5);
	
	/*UINT16 TempUin16[2] = { 0 };
	TempUin16[0] = m_InputsFsm.Interlocks.BsmInterlock;
	TempUin16[1] = m_InputsFsm.Interlocks.NgrInterlock;
	ConvertModubsFormat(TempUin16, SendBuf, Postion, 2);*/
	UINT16 TempUin16[1] = { 0 };
	TempUin16[0] = m_InputsFsm.Interlocks.NgrInterlock;
	ConvertModubsFormat(TempUin16, SendBuf, Postion, 1);

	return TRUE;
}

/******************************************************************************
* Function: PackageBodySysStatus(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodySysStatus(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_sys_status:: input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_sys_status:: sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_SYS_STATUS;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_SYS_STATUS_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_SYS_STATUS_LEN;
	
	//package data struct TLV--data V
	SendBuf[(*Postion)++] = 0;						//fill high byte
	SendBuf[(*Postion)++] = static_cast<UINT8>(m_InputsFsm.CurrentState);	//fill low byte
	SendBuf[(*Postion)++] = m_InputsHalState.WatchDogState;					//fill 1 byte

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyUnready(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyUnready(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_unready:: input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_unready:: sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_UNREADY;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_UNREADY_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_UNREADY_LEN;

	//package data struct TLV--data V
	SendBuf[(*Postion)++] = m_InputsFsm.Unreadys.NGRUnready;
	SendBuf[(*Postion)++] = m_InputsFsm.Unreadys.BgmUnready;
	SendBuf[(*Postion)++] = m_InputsFsm.Unreadys.BsmUnready;
	SendBuf[(*Postion)++] = m_InputsFsm.Unreadys.IgsUnready;

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyEvent(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyEvent(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::<PackageBodyEvent>:: input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::<PackageBodyEvent>:: sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_EVENT;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_EVENT_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_EVENT_LEN;

	//if (m_FmSlvOffGanty.FkpPrepareKey)
	//{
	//	SendBuf[(*Postion)++] = PREPARE_EVENT;
	//}
	//else if (m_FmSlvOffGanty.FkpBeamOnKey)
	//{
	//	SendBuf[(*Postion)++] = BEAMON_EVENT;
	//}
	//else
	//{
		SendBuf[(*Postion)++] = 0;
	//}

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyCtrlState(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyCtrlState(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
				m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_controller_state:: input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
				m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_controller_state:: sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_CTRL_STATE;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_CTRL_STATE_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_CTRL_STATE_LEN;

	//package data struct TLV--data V
	UINT8 EtherCAT = 0;
	UINT8 Emulator = 0;
	UINT8 ControllerEmuMode = 0;
	//handle EtherCAT input parameter
	EtherCAT |= (m_InputsHalState.EthercatState.OnGantryRTC == 8 ? 0x01 : 0);
	EtherCAT |= (m_InputsHalState.EthercatState.BGM == 8 ? 0x02 : 0);
	EtherCAT |= (m_InputsHalState.EthercatState.RGS == 8 ? 0x04 : 0);
	EtherCAT |= (m_InputsHalState.EthercatState.BSM == 8 ? 0x08 : 0);
	EtherCAT |= (m_InputsHalState.EthercatState.IGS == 8 ? 0x10 : 0);
	//handle EmulatorMode parameter
	Emulator |= (m_InputsHalState.EmulateState.OnGantryRTC == TRUE ? 0x01 : 0);
	Emulator |= (m_InputsHalState.EmulateState.BGM == TRUE ? 0x02 : 0);
	Emulator |= (m_InputsHalState.EmulateState.RGS == TRUE ? 0x04 : 0);
	Emulator |= (m_InputsHalState.EmulateState.BSM == TRUE ? 0x08 : 0);
	Emulator |= (m_InputsHalState.EmulateState.IGS == TRUE ? 0x10 : 0);
	//handle Controller Emulator parameter
	ControllerEmuMode |= (m_InputsHalState.ControllerEmuMode.RgsCtrl == TRUE ? 0x04 : 0);
	ControllerEmuMode |= (m_InputsHalState.ControllerEmuMode.BsmCtrl == TRUE ? 0x08 : 0);
	ControllerEmuMode |= (m_InputsHalState.ControllerEmuMode.IgsCtrl == TRUE ? 0x10 : 0);

	SendBuf[(*Postion)++] = EtherCAT;
	SendBuf[(*Postion)++] = Emulator;
	SendBuf[(*Postion)++] = ControllerEmuMode;

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyGeometry(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyGeometry(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::<mc_package_body_geometry>:: input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "%d::CTCPServer::mc_package_body_geometry:: sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	//package data struct TLV--data T
	SendBuf[(*Postion)++] = MC_UNIT_ID_GEOMETRY;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	//package data struct TLV--data L
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_MLC_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_MLC_LEN;

	//package data struct TLV--data V
	for (UINT16 i = 0; i < (MC_UNIT_MLC_LEN / 4); i++)
	{
		float_union_t temp_float_union;
		temp_float_union.value = i;
		SendBuf[(*Postion)++] = temp_float_union.float_byte.lw_high_byte;
		SendBuf[(*Postion)++] = temp_float_union.float_byte.lw_low_byte;
		SendBuf[(*Postion)++] = temp_float_union.float_byte.hw_high_byte;
		SendBuf[(*Postion)++] = temp_float_union.float_byte.hw_low_byte;
	}

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyBsm(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe: package modulator data into sendbuf
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyBsm(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_bsm>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_body_bsm>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	/*package data struct TCLV--data T*/
	SendBuf[(*Postion)++] = MC_UNIT_ID_BSM;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	/*package data struct TCLV--data L*/
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_BSM_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_BSM_LEN;

	/*package data struct TLV--data V*/
	FLOAT temp_float_array[7] = { 0 };
	FLOAT MLCActPos[128] = { 0 };
	UINT16 BsmStatus = 0;
	UINT8  CollimatorPosition = 0;
	UINT32 InitResult[4] = { 0 };
	FLOAT temp_float_array1[2] = { 0 };

	temp_float_array[0] = m_InputsBsm.bsm_Head_p1;
	temp_float_array[1] = m_InputsBsm.bsm_Head_p2;
	temp_float_array[2] = m_InputsBsm.HeadSpeed;	
	temp_float_array[3] = m_InputsBsm.bsm_jaw1_p1;
	temp_float_array[4] = m_InputsBsm.bsm_jaw1_p2;
	temp_float_array[5] = m_InputsBsm.bsm_jaw2_p1;
	temp_float_array[6] = m_InputsBsm.bsm_jaw2_p2;	
	
	memcpy(MLCActPos, m_InputsBsm.MLCActPos, 512);
	BsmStatus = m_InputsBsm.BSMStatus;
	CollimatorPosition = m_InputsBsm.CollimatorPosition;

	ConvertModubsFormat(temp_float_array, SendBuf, Postion, 7);	//package one float value into send buffer
	ConvertModubsFormat(MLCActPos, SendBuf, Postion, 128);
	ConvertModubsFormat(&BsmStatus,SendBuf,Postion,1 );
	SendBuf[(*Postion)++] = CollimatorPosition;

	InitResult[0] = m_InputsBsm.InitResult0;
	InitResult[1] = m_InputsBsm.InitResult1;
	InitResult[2]= m_InputsBsm.InitResult2;
	InitResult[3] = m_InputsBsm.InitResult3;

	ConvertModubsFormat(InitResult, SendBuf, Postion,4);
	temp_float_array1[0] = m_InputsBsm.LeafMaxSpeed;
	temp_float_array1[1] = m_InputsBsm.JawMaxSpeed;
	ConvertModubsFormat(temp_float_array1, SendBuf, Postion, 2);	//package one float value into send buffer
	return TRUE;
}

/******************************************************************************
* Function: PackageBodyDose(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe: package dose data into sendbuf
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyDose(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
		#if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::sendbuf is not enough", __LINE__);
		#endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	/*package data struct TCLV--data T*/
	SendBuf[(*Postion)++] = MC_UNIT_ID_DOSE;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	/*package data struct TCLV--data L*/
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_DOSE_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_DOSE_LEN;

	/*package data struct TLV--data V*/
	SendBuf[(*Postion)++] = (UINT8)(m_InputsDose.DoseInformation1 >> 8);
	SendBuf[(*Postion)++] = (UINT8)m_InputsDose.DoseInformation1;
	SendBuf[(*Postion)++] = (UINT8)(m_InputsDose.DoseInformation2 >> 8);
	SendBuf[(*Postion)++] = (UINT8)m_InputsDose.DoseInformation2;

	UINT16 DoseRateInterlock = 0;
	if (m_InputsDose.LowDoseRateInterlock)
		DoseRateInterlock |= 0x02;
	else
		DoseRateInterlock &= ~0x02;

	if (m_InputsDose.HighDoseRateInterlock)
		DoseRateInterlock |= 0x01;
	else
		DoseRateInterlock &= ~0x01;

	SendBuf[(*Postion)++] = (UINT8)(DoseRateInterlock >> 8);
	SendBuf[(*Postion)++] = (UINT8)DoseRateInterlock;
	
	return TRUE;
}
/******************************************************************************
* Function: PackageBodyIgs(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe: package dose data into sendbuf
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyIgs(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
     #if MC_COM_DEBUG_EXP_RD
	 m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::input parameter is invaild", __LINE__);
     #endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
      #if MC_COM_DEBUG_EXP_RD
	  m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::sendbuf is not enough", __LINE__);
      #endif

		return FALSE;
	}

	/*package body data into sendbuf*/
	/*package data struct TCLV--data T*/
	SendBuf[(*Postion)++] = MC_UNIT_ID_IGS;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	/*package data struct TCLV--data L*/
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_IGS_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_IGS_LEN;

	/*package data struct TLV--data V*/
	SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.MvPosReady);
	SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.KvPosReady);
	SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.CollimatorPosReady);
	SendBuf[(*Postion)++] = m_InputsIgs.HVGeneratorHU;

	UINT16 TempUint16Array[2] = { 0 };
	TempUint16Array[0] = m_InputsIgs.KvPanelErrorcode;
	TempUint16Array[1] = m_InputsIgs.MVPanelErrorcode;
	ConvertModubsFormat(TempUint16Array, SendBuf, Postion, 2);	//package  uint16 value into send buffer

	INT16 TempInt16Array[4] = { 0 };
	TempInt16Array[0] = m_InputsIgs.CollimatorCross;
	TempInt16Array[1] = m_InputsIgs.CollimatorLong;
	TempInt16Array[2] = m_InputsIgs.CollimatorOffsetCross;
	TempInt16Array[3] = m_InputsIgs.CollimatorOffsetLong;
	ConvertModubsFormat(TempInt16Array, SendBuf, Postion, 4);	//package  int16 value into send buffer

	INT32 TempInt32Array[4] = { 0 };
	TempInt32Array[0] = m_InputsIgs.KVOffset1;
	TempInt32Array[1] = m_InputsIgs.KVOffset2;
	TempInt32Array[2] = m_InputsIgs.MVOffset1;
	TempInt32Array[3] = m_InputsIgs.MVOffset2;
	ConvertModubsFormat(TempInt32Array, SendBuf, Postion, 4);	//package  int32 value into send buffer

	UINT32 TempUint32Array[2] = { 0 };
	TempUint32Array[0] = m_InputsIgs.IcuErrorCode;
	TempUint32Array[1] = m_InputsIgs.HighVoltageGeneratorErrorCode;
	ConvertModubsFormat(TempUint32Array, SendBuf, Postion, 2);	//package  uint32 value into send buffer

	FLOAT TempFloatArray[2] = { 0 };
	TempFloatArray[0] = m_InputsIgs.KvPosition;
	TempFloatArray[1] = m_InputsIgs.MvPosition;

	ConvertModubsFormat(TempFloatArray, SendBuf, Postion, 2);	//package  uint32 value into send buffer


	return TRUE;
}
/******************************************************************************
* Function: PackageBodyIgsICu(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe: package dose data into sendbuf
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageBodyIgsIcu(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
       #if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::input parameter is invaild", __LINE__);
        #endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
        #if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::sendbuf is not enough", __LINE__);
        #endif

		return FALSE;
	}
	/*package body data into sendbuf*/
	/*package data struct TCLV--data T*/
	SendBuf[(*Postion)++] = MC_UNIT_ID_IGSICU;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = MC_FUNC_RESERVE;

	/*package data struct TCLV--data L*/
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_IGSICU_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_IGSICU_LEN;

	/*package data struct TLV--data V*/
	SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.IcuFocusExp);
	SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.IcuFrequencyExp);
	SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.IcuKVExp);

	UINT16 TempUint16Array[4] = { 0 };
	TempUint16Array[0] = m_InputsIgs.IcuMAExp;
	TempUint16Array[1] = m_InputsIgs.IcuMSExp;
	TempUint16Array[2] = (UINT16)ceil_((FLOAT)m_InputsIgs.ExposeListLong / 20);
	TempUint16Array[3] = m_InputsIgs.ExposeListLong;

	ConvertModubsFormat(TempUint16Array, SendBuf, Postion, 4);	//package  uint16 value into send buffer

	return TRUE;
}

/******************************************************************************
* Function: PackageBodyIgsExposeGantryList(UCHAR *SendBuf, UINT16 *Postion)
*
* Describe : package dose data into sendbuf
*
* Input :
*
* Output : None
*
* Return : TRUE or FALSE
*
* Others :
*******************************************************************************/
BOOL CTCPServer::PackageBodyIgsExposeGantryList(UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
       #if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::input parameter is invaild", __LINE__);
        #endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= MC_COM_SEND_BUF_SIZE - 1)
	{
         #if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::sendbuf is not enough", __LINE__);
       #endif

		return FALSE;
	}
	if (m_IgsExpListGroup < 1 && m_IgsExpListGroup > 30)
	{
        #if MC_COM_DEBUG_EXP_RD
		m_Trace.Log(tlInfo, "Line:%d::<PackageBodyDose>::IgsExposeList buf is not enough ", __LINE__);
        #endif

		return FALSE;
	}


	/*package body data into sendbuf*/
	/*package data struct TCLV--data T*/
	SendBuf[(*Postion)++] = MC_UNIT_ID_IGSEXPOSE_GANTRY_LIST;

	/*package data struct TCLV--data C*/
	SendBuf[(*Postion)++] = m_IgsExpListGroup;


	/*package data struct TCLV--data L*/
	SendBuf[(*Postion)++] = (UINT8)(MC_UNIT_IGSEXPOSE_GANTRY_LIST_LEN >> 8);
	SendBuf[(*Postion)++] = (UINT8)MC_UNIT_IGSEXPOSE_GANTRY_LIST_LEN;
	BYTE  TempBuf[1154] = { 0 };
	int j = 0;
	for (int i = 0; i < 20; i++)
	{
		SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].Hour);
		SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].Minite);
		SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].Second);
		SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].CollimatorType);
		SendBuf[(*Postion)++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].PanelType);
		TempBuf[j++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].Hour);
		TempBuf[j++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].Minite);
		TempBuf[j++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].Second);
		TempBuf[j++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].CollimatorType);
		TempBuf[j++] = (UINT8)(m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].PanelType);

		uint16_union_t TempUint16Union;
		UINT16 TempUint16Array = 0;
		TempUint16Array = m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].MilliSecond;
		TempUint16Union.value = TempUint16Array;
		ConvertModubsFormat(&TempUint16Array, SendBuf, Postion, 1);	//package  uint16 value into send buffer

		TempBuf[j++] = TempUint16Union.uint16_byte.low_byte;
		TempBuf[j++] = TempUint16Union.uint16_byte.high_byte;

		uint32_union_t TempUint32Union;
		UINT32 TempUint32Array = 0;
		TempUint32Array = m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].OpenSourceTimer;
		TempUint32Union.value = TempUint32Array;
		ConvertModubsFormat(&TempUint32Array, SendBuf, Postion, 1);	//package  uint32 value into send buffer

		TempBuf[j++] = TempUint32Union.uint32_byte.lw_low_byte;
		TempBuf[j++] = TempUint32Union.uint32_byte.lw_high_byte;
		TempBuf[j++] = TempUint32Union.uint32_byte.hw_low_byte;
		TempBuf[j++] = TempUint32Union.uint32_byte.hw_high_byte;

		float_union_t TempFloatUnion[3];
		FLOAT TempFloatArray[3] = { 0 };
		TempFloatArray[0] = m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].GantryPosition;
		TempFloatArray[1] = m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].GantrySpeed;
		TempFloatArray[2] = m_InputsIgs.ExposeGantryList[m_IgsExpListGroup - 1][i].Panel_Position;
		ConvertModubsFormat(TempFloatArray, SendBuf, Postion, 3);	//package  uint32 value into send buffer

		for (int k = 0; k < 3; k++)
		{
			TempFloatUnion[k].value = TempFloatArray[k];
			TempBuf[j++] = TempFloatUnion[k].float_byte.lw_low_byte;
			TempBuf[j++] = TempFloatUnion[k].float_byte.lw_high_byte;
			TempBuf[j++] = TempFloatUnion[k].float_byte.hw_low_byte;
			TempBuf[j++] = TempFloatUnion[k].float_byte.hw_high_byte;
		}
	}
	UINT16 TempNum = 0;
	uint16_union_t TempUint16Union;
	
	if (m_InputsIgs.ExposeListGroup != 0)
	{

		if (m_IgsExpListGroup == m_InputsIgs.ExposeListGroup)
		{
			TempNum = m_InputsIgs.ExposeListNum;
		}
		else if (m_IgsExpListGroup > m_InputsIgs.ExposeListGroup)
		{
			TempNum = 0;
		}
		else
		{
			TempNum = 20;
		}
	}
	else
	{
		TempNum = 0;
	}
	ConvertModubsFormat(&TempNum, SendBuf, Postion, 1);	//package  uint16 value into send buffer
	TempUint16Union.value = TempNum;
	

	TempBuf[j++] = TempUint16Union.uint16_byte.low_byte;
	TempBuf[j++] = TempUint16Union.uint16_byte.high_byte;
	UINT32 TempUint32Array = Crc32.Crc32Buffer(TempBuf, MC_UNIT_IGSEXPOSE_GANTRY_LIST_LEN - 4);
	ConvertModubsFormat(&TempUint32Array, SendBuf, Postion, 1);	//package  uint32 value into send buffer

	return TRUE;
}
/******************************************************************************
* Function:
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ConvertModubsFormat(UINT16 *src, UCHAR *dst, UINT16 *postion, UINT32 number)
{
	/*availability check*/
	if (src == NULL || dst == NULL || postion == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if (0 == number)	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter number is invaild", __LINE__);
		#endif

		return FALSE;
	}

	if (sizeof(UINT16)*number >= (MC_COM_SEND_BUF_SIZE-*postion))	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter postion is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*convert data*/
	uint16_union_t temp_uint16_union;

	for (size_t i = 0; i < number; i++)
	{
		temp_uint16_union.value = src[i];	//copy one uint16 value
		dst[(*postion)++] = temp_uint16_union.uint16_byte.high_byte;	//fill higt byte
		dst[(*postion)++] = temp_uint16_union.uint16_byte.low_byte;	//fill low byte
	}

	return TRUE;
}

/******************************************************************************
* Function:
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ConvertModubsFormat(INT16 *src, UCHAR *dst, UINT16 *postion, UINT32 number)
{
	/*availability check*/
	if (src == NULL || dst == NULL || postion == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if (0 == number)	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter number is invaild", __LINE__);
		#endif

		return FALSE;
	}

	if (sizeof(INT16)*number >= (MC_COM_SEND_BUF_SIZE - *postion))	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter postion is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*convert data*/
	int16_union_t temp_int16_union;

	for (size_t i = 0; i < number; i++)
	{
		temp_int16_union.value = src[i];	//copy one uint16 value
		dst[(*postion)++] = temp_int16_union.int16_byte.high_byte;	//fill higt byte
		dst[(*postion)++] = temp_int16_union.int16_byte.low_byte;	//fill low byte
	}

	return TRUE;
}

/******************************************************************************
* Function:
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ConvertModubsFormat(UINT32 *src, UCHAR *dst, UINT16 *postion, UINT32 number)
{
	/*availability check*/
	if (src == NULL || dst == NULL || postion == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if (0 == number)	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter number is invaild", __LINE__);
		#endif

		return FALSE;
	}

	if (sizeof(UINT32)*number >= (MC_COM_SEND_BUF_SIZE - *postion))	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter postion is invaild", __LINE__);
		#endif

		return FALSE;
	}
	
	/*convert data*/
	uint32_union_t temp_uint32_union;

	for (size_t i = 0; i < number; i++)
	{
		temp_uint32_union.value = src[i];
		dst[(*postion)++] = temp_uint32_union.uint32_byte.lw_high_byte;	//fill low word(high byte)
		dst[(*postion)++] = temp_uint32_union.uint32_byte.lw_low_byte;	//fill low word(low byte)

		dst[(*postion)++] = temp_uint32_union.uint32_byte.hw_high_byte;	//fill high word(higt byte)
		dst[(*postion)++] = temp_uint32_union.uint32_byte.hw_low_byte;	//fill higt word(low byte)
	}

	return TRUE;
}

/******************************************************************************
* Function:
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ConvertModubsFormat(INT32 *src, UCHAR *dst, UINT16 *postion, UINT32 number)
{
	/*availability check*/
	if (src == NULL || dst == NULL || postion == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if (0 == number)	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter number is invaild", __LINE__);
		#endif

		return FALSE;
	}

	if (sizeof(INT32)*number >= (MC_COM_SEND_BUF_SIZE - *postion))	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter postion is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*convert data*/
	int32_union_t temp_int32_union;

	for (size_t i = 0; i < number; i++)
	{
		temp_int32_union.value = src[i];
		dst[(*postion)++] = temp_int32_union.int32_byte.lw_high_byte;	//fill low word(high byte)
		dst[(*postion)++] = temp_int32_union.int32_byte.lw_low_byte;	//fill low word(low byte)

		dst[(*postion)++] = temp_int32_union.int32_byte.hw_high_byte;	//fill high word(higt byte)
		dst[(*postion)++] = temp_int32_union.int32_byte.hw_low_byte;	//fill higt word(low byte)
	}

	return TRUE;
}

/******************************************************************************
* Function:
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ConvertModubsFormat(FLOAT *src, UCHAR *dst, UINT16 *postion, UINT32 number)
{
	/*availability check*/
	if (src == NULL || dst == NULL || postion == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if (0 == number)	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter number is invaild", __LINE__);
		#endif

		return FALSE;
	}

	if (sizeof(FLOAT)*number >= (MC_COM_SEND_BUF_SIZE - *postion))	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_convert_modubs_format>::parameter postion is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*convert data*/
	float_union_t temp_uint32_float;

	for (size_t i = 0; i < number; i++)
	{
		temp_uint32_float.value = src[i];
		dst[(*postion)++] = temp_uint32_float.float_byte.lw_high_byte;	//fill low word(high byte)
		dst[(*postion)++] = temp_uint32_float.float_byte.lw_low_byte;	//fill low word(low byte)

		dst[(*postion)++] = temp_uint32_float.float_byte.hw_high_byte;	//fill high word(higt byte)
		dst[(*postion)++] = temp_uint32_float.float_byte.hw_low_byte;	//fill higt word(low byte)
	}

	return TRUE;
}

/******************************************************************************
* Function: PackageTail(PackageTail_s PackageHead, UCHAR *SendBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::PackageTail(PackageTail_s PackageTailer, UCHAR *SendBuf, UINT16 *Postion)
{
	/*availability check*/
	if (SendBuf == NULL || Postion == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_tail>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*correctness check*/
	if ((*Postion + 1) >= (MC_COM_SEND_BUF_SIZE - 1))	//have no enough space
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_package_tail>::parameter postion is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*convert data*/
	SendBuf[(*Postion)++] = PackageTailer.StopFlag;	//postion dont add

	return TRUE;
}

/******************************************************************************
* Function: ResponseGuiRequest(VOID)
*
* Describe: resolve data received
*
* Input   : None
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseGuiRequest(VOID)
{
	UINT16 DequeueBytes = 0;
	UINT32 ReadRequestFlags = 0;									//bit operation--one bit represent one data unit read request enable or disable

	/* clear dequeue buffer*/
	memset(DequeueBuf, 0, sizeof(DequeueBuf));

	/*check write receive queue*/
	if (QUEUE_NONEMPTY == WriteQueue.IsEmpty())						//check write queue
	{
		ResetModuleOutput();										//manual reset command(work together with auto reset)

		Spinlock.Lock();											//into critical area
		DequeueBytes = WriteQueue.Dequeue(DequeueBuf);				//pop a write request
		Spinlock.Unlock();											//out critical area

		#if MC_COM_TRACE_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse>:: Write Queue poped  %d bytes", __LINE__, dequeue_bytes);
		#endif
		
		ResponseWriteReq(DequeueBuf);								//response write request

		return TRUE;												//flesh socket send buffer
	}
	else
	{
																	//do nothing
	}

	/*check read receive queue*/					
	do{																//pop all read request in receive queue
		Spinlock.Lock();										
		DequeueBytes = CycleQueue.Dequeue(DequeueBuf);				//pop read request from queue
		Spinlock.Unlock();

		#if MC_COM_TRACE_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse>:: Read Queue poped  %d bytes", __LINE__, dequeue_bytes);
		#endif
			
		GetReadReqIdentifier(DequeueBuf, DequeueBytes, &ReadRequestFlags);	/*get uint identifer of read request*/
	} while (0 != DequeueBytes);

	//Had read request
	if (ReadRequestFlags == 0)
	{
		return FALSE;	//no read request
	}
	else
	{
		ResponseReadReq(DequeueBuf, ReadRequestFlags);					//response read request with unit identifer

		return TRUE;	//flesh socket send buffer
	}
}

/******************************************************************************
* Function: ResponseReadReq(UCHAR *DequeueBuf, UINT16 Flags)
*
* Describe: response read request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseReadReq(UCHAR *DequeueBuf, UINT32 Flags)
{
	/*input parameters availability check*/
	if (DequeueBuf == NULL || Flags == NULL)
	{
		#if MC_COM_DEBUG_EXP_RD
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*package read reponse header*/
	PackageHead_s PackageHead;
	PackageHead.SequenceNum.uint16_byte.high_byte = DequeueBuf[0];	//sequence number
	PackageHead.SequenceNum.uint16_byte.low_byte = DequeueBuf[1];	//sequence number

	PackageHead.SenderID = MC_MACHINE_ID_LM;	//sender identifier:low machine
	PackageHead.ReceiverID = MC_MACHINE_ID_UM;	//receiver identifier:up machine
	PackageHead.RequestType = MC_READ_FEEDBACK;	//request type:read feedback
	PackageHeader(PackageHead, SendBuffer, &SendBufferCursor);

	/*package read reponse body*/
	(Flags & MC_UNIT_ID_MODULATOR_FlAG)  ? PackageBody(MC_UNIT_ID_MODULATOR, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_GUN_FlAG)        ? PackageBody(MC_UNIT_ID_GUN, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_WATER_FlAG)      ? PackageBody(MC_UNIT_ID_COOLING, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_AFC_FlAG)        ? PackageBody(MC_UNIT_ID_AFC, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_BEAM_FlAG)       ? PackageBody(MC_UNIT_ID_BEAM, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_INTL_FlAG)       ? PackageBody(MC_UNIT_ID_INTERLOCK, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_UNREADY_FlAG)    ? PackageBody(MC_UNIT_ID_UNREADY, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_SYS_STATUS_FlAG) ? PackageBody(MC_UNIT_ID_SYS_STATUS, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_GEOMETRY_FlAG)   ? PackageBody(MC_UNIT_ID_GEOMETRY, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_EVENT_FlAG)		 ? PackageBody(MC_UNIT_ID_EVENT, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_CTRL_STATE_FlAG) ? PackageBody(MC_UNIT_ID_CTRL_STATE, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_BSM_FlAG)		 ? PackageBody(MC_UNIT_ID_BSM, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_DOSE_FlAG)		 ? PackageBody(MC_UNIT_ID_DOSE, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_IGS_FlAG)        ? PackageBody(MC_UNIT_ID_IGS, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_IGSICU_FlAG)     ? PackageBody(MC_UNIT_ID_IGSICU, SendBuffer, &SendBufferCursor) : NULL;
	//(Flags & MC_UNIT_ID_IGSEXPOSE_LIST_FlAG) ? PackageBody(MC_UNIT_ID_IGSEXPOSE_LIST, SendBuffer, &SendBufferCursor) : NULL;
	(Flags & MC_UNIT_ID_IGSEXPOSE_GANTRY_LIST_FlAG) ? PackageBody(MC_UNIT_ID_IGSEXPOSE_GANTRY_LIST, SendBuffer, &SendBufferCursor) : NULL;


	/*package read reponse tail*/
	PackageTail_s PackageTailer;
	PackageTailer.StopFlag = MC_COM_STOP_BYTE;
	PackageTail(PackageTailer, SendBuffer, &SendBufferCursor);
	
	/*send packaged data to client*/
	ULONG send_count;
	if (S_OK == m_spTcpProt->SendData(ClientSocket, SendBufferCursor, SendBuffer, send_count))
	{
		#if MC_COM_DEBUG_COM_TRACE
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read>::Send data:%d bytes", __LINE__, send_count);
		#endif

			SendBufferCursor = 0;	//reset send buffer cursor
		
		return TRUE;
	}
	else
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read>::Fail to send data", __LINE__);
		#endif

		return FALSE;
	}

	return TRUE;
}

/******************************************************************************
* Function: GetReadReqIdentifier(UCHAR *DequeueBuf, UINT32 Num, UINT16 *Flags)
*
* Describe: get unit identifer of read request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::GetReadReqIdentifier(UCHAR *DequeueBuf, UINT16 Num, UINT32 *Flags)
{
	/*availability check*/
	if (DequeueBuf == NULL || Flags == NULL)
	{
		#if MC_COM_DEBUG_EXCEPTION
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::input parameter is invaild!", __LINE__, Num);
		#endif

		return FALSE;
	}
	else if (Num == 0)
	{
		return FALSE;	//there is no read request
	}
	else
	{
		//do nothing
	}

	UINT16 i = 5;	//postion of unit identifer
	/*get read request unit identifier*/
	while ((DequeueBuf[i] != MC_COM_STOP_BYTE) && (i< Num))
	{
		switch (DequeueBuf[i])
		{
			case MC_UNIT_ID_MODULATOR:
			{
				*Flags |= MC_UNIT_ID_MODULATOR_FlAG;	//enable modulator read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get modulator read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_GUN:
			{
				*Flags |= MC_UNIT_ID_GUN_FlAG;	//enable gun read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get gun read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_COOLING:
			{
				*Flags |= MC_UNIT_ID_WATER_FlAG;	//enable water(cooling) read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get water read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_AFC:
			{
				*Flags |= MC_UNIT_ID_AFC_FlAG;		//enable afc read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get afc read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_BEAM:
			{
				*Flags |= MC_UNIT_ID_BEAM_FlAG;		//enable beam read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get dose read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_GEOMETRY:
			{
				*Flags |= MC_UNIT_ID_GEOMETRY_FlAG;	//enable bsm read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get geometry read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_INTERLOCK:
			{
				*Flags |= MC_UNIT_ID_INTL_FlAG;	//enable interlock read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get interlock read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_UNREADY:
			{
				*Flags |= MC_UNIT_ID_UNREADY_FlAG;	//enable unready read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get unready read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_SYS_STATUS:
			{
				*Flags |= MC_UNIT_ID_SYS_STATUS_FlAG;	//enable system status read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get system status read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_EVENT:
			{
				*Flags |= MC_UNIT_ID_EVENT_FlAG;	//enable event read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get event read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_CTRL_STATE:
			{
				*Flags |= MC_UNIT_ID_CTRL_STATE_FlAG;	//enable controller state read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get controller state read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_BSM:
			{
				*Flags |= MC_UNIT_ID_BSM_FlAG;	//enable bsm read request
				#if MC_COM_TRACE_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get bsm read request", __LINE__);
				#endif

				break;
			}
			case MC_UNIT_ID_DOSE:
			{
				*Flags |= MC_UNIT_ID_DOSE_FlAG;	//enable dose read request
				#if MC_COM_TRACE_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get dose read request", __LINE__);
				#endif

				break;
			}

			case MC_UNIT_ID_IGS:
			{
				*Flags |= MC_UNIT_ID_IGS_FlAG;	//enable igs read request
                #if MC_COM_TRACE_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get dose read request", __LINE__);
                #endif

				break;
			}
			case MC_UNIT_ID_IGSICU:
			{
				*Flags |= MC_UNIT_ID_IGSICU_FlAG;	//enable igs read request
                #if MC_COM_TRACE_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get dose read request", __LINE__);
                 #endif

				break;
			}
			
			case MC_UNIT_ID_IGSEXPOSE_GANTRY_LIST:
			{
				*Flags |= MC_UNIT_ID_IGSEXPOSE_GANTRY_LIST_FlAG;	//enable igs read request
                #if MC_COM_TRACE_RD
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::get dose read request", __LINE__);
               #endif

				break;
			}
			default:	//error
			{
				#if MC_COM_DEBUG_EXP_RD
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::unknown data unit::0x%x", __LINE__, DequeueBuf[i]);
				#endif

				//return FALSE;
				break;
			}
		}
		i++;
		if (*Flags & MC_UNIT_ID_IGSEXPOSE_GANTRY_LIST_FlAG) // igs exposr list tage  C is group
		{
			m_IgsExpListGroup = DequeueBuf[i++];
		}
		else
		{
			UINT8 ControlByte = DequeueBuf[i++];	//get control byte
		}
	
	}

	if (i != Num-1 && i < Num-1)	//there is no read request identifer
		m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::there is not a separate package!!", __LINE__);
	else if (i == Num && DequeueBuf[i] != MC_COM_STOP_BYTE)
		m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_read_get_identifier>::there is not a correct package!!", __LINE__);
	else
	{

	}

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReq(UCHAR *DequeueBuf)
*
* Describe: response write request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReq(UCHAR *DequeueBuf)
{
	/*input parameters availability check*/
	if (DequeueBuf == NULL)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::input parameter is invaild", __LINE__);
		#endif

		return FALSE;
	}

	/*package reponse message header*/
	PackageHead_s PackageHead;
	PackageHead.SequenceNum.uint16_byte.high_byte = DequeueBuf[0];	//sequence number
	PackageHead.SequenceNum.uint16_byte.low_byte  = DequeueBuf[1];	//sequence number

	PackageHead.SenderID = MC_MACHINE_ID_LM;							//sender identifier:low machine
	PackageHead.ReceiverID = MC_MACHINE_ID_UM;						//receiver identifier:up machine
	PackageHead.RequestType = MC_WRITE_FEEDBACK;						//request type:write feedback
	PackageHeader(PackageHead, SendBuffer, &SendBufferCursor);

	/*decode wirte data and package reponse body*/
	UINT16 i = 5;	//'T' start byte in TCLV struct
	BOOL ResolveFaultFlag = FALSE;
	while (MC_COM_STOP_BYTE != DequeueBuf[i] && ResolveFaultFlag == FALSE)
	{
		switch (DequeueBuf[i++])
		{
			case MC_UNIT_ID_MODULATOR_WR:
			{
				if (FALSE == ResponseWriteReqModulator(DequeueBuf, &i))				//resolve modulator write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_MODULATOR_WR;	//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package modulator write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_GUN_WR:
			{
				if (FALSE == ResponseWriteReqGun(DequeueBuf, &i))							//resolve gun write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_GUN_WR;			//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package gun write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_AFC_WR:
			{
				if(FALSE == ResponseWriteReqAfc(DequeueBuf, &i))							//resolve afc write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_AFC_WR;			//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package afc write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_AFC_CTL_WR:
			{
				if (FALSE == ResponseWriteReqAfcCtl(DequeueBuf, &i))						//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_AFC_CTL_WR;		//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package afc ctrl write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_DOSE_WR:
			{
				if (FALSE == ResponseWriteReqDose(DequeueBuf, &i))					//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_DOSE_WR;			//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package dose write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_BEAM_WR:
			{
				if (FALSE == ResponseWriteReqBeam(DequeueBuf, &i))						//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_BEAM_WR;			//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package beam write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_CMD:
			{
				if(FALSE == ResponseWriteReqCmd(DequeueBuf, &i))						//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_CMD;				//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package cmd write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_PRF_WR:
			{
				if (FALSE == ResponseWriteReqPrf(DequeueBuf, &i))							//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_PRF_WR;			//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package prf write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_PLANCP_WR:
			{
				switch (ResponseWriteReqCP(DequeueBuf, &i))
				{
					case FALSE:
						ResolveFaultFlag = TRUE;
						SendBuffer[SendBufferCursor++] = MC_UNIT_ID_PLANCP_WR;		//package reponse package body 'T'
						SendBuffer[SendBufferCursor++] = CP_CRC_ERROR;			//package reponse package body 'C'
						break;
					case EXCEPT_MISS_MIDDLE:
						return TRUE;	//new cycle
					case EXCEPT_MISS_LAST:
						return TRUE;	//new cycle
					case TRUE:
						SendBuffer[SendBufferCursor++] = MC_UNIT_ID_PLANCP_WR;		//package reponse package body 'T'
						SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
						#if MC_COM_TRACE_WR
						m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package cp write response", __LINE__);
						#endif
						break;
					default:
						#if MC_COM_DEBUG_EXP_WR
						m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::unknown return value!", __LINE__);
						#endif
						break;
				}
				break;
			}
			case MC_UNIT_ID_EMULAOTR_EN:
			{
				if (FALSE == ResponseWriteReqEmulator(DequeueBuf, &i))						//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_EMULAOTR_EN;		//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package emulator write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_PLANBEAM_WR:
			{
				if (FALSE == ResponseWriteReqPlanBeam(DequeueBuf, &i))			//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_PLANBEAM_WR;		//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package plan beam write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_CTRL_STATE_WR:
			{
				if (FALSE == ResponseWriteReqCtrlState(DequeueBuf, &i))						//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_CTRL_STATE_WR;	//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package controller state write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_BSM_WR:
			{
				if (FALSE == ResponseWriteReqBsm(DequeueBuf, &i))							//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_BSM_WR;			//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package prf write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_VMAT_PARA_WR:
			{
				if (FALSE == ResponseWriteReqVMAT(DequeueBuf, &i))			//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_VMAT_PARA_WR;	//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
				#if MC_COM_TRACE_WR
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package prf write response", __LINE__);
				#endif
				break;
			}
			case MC_UNIT_ID_IGS_WR:
			{
				if (FALSE == ResponseWriteReqIgs(DequeueBuf, &i))			//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_IGS_WR;	//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
                #if MC_COM_TRACE_WR
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package prf write response", __LINE__);
                #endif
				break;
			}
			case MC_UNIT_ID_IGSICU_WR:
			{
				if (FALSE == ResponseWriteReqIgsIcu(DequeueBuf, &i))			//resolve write request data
				{
					ResolveFaultFlag = TRUE;
					break;
				}
				SendBuffer[SendBufferCursor++] = MC_UNIT_ID_IGSICU_WR;	//package reponse package body 'T'
				SendBuffer[SendBufferCursor++] = MC_FUNC_RESERVE;			//package reponse package body 'C'
                #if MC_COM_TRACE_WR
				m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::package prf write response", __LINE__);
                #endif
				break;
			}
			default:
			{
				#if MC_COM_DEBUG_EXP_WR
					m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::unknown unit identifier::0x%x", __LINE__, DequeueBuf[i-1]);
				#endif

					ResolveFaultFlag = TRUE;
				break;
			}
		}
	}

	/*package tail*/
	PackageTail_s PackageTailer;
	PackageTailer.StopFlag = MC_COM_STOP_BYTE;
	PackageTail(PackageTailer, SendBuffer, &SendBufferCursor);

	/*send packaged data to client*/
	ULONG send_count;
	if (S_OK == m_spTcpProt->SendData(ClientSocket, SendBufferCursor, SendBuffer, send_count))
	{
		#if MC_COM_TRACE_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::Send data:%d bytes", __LINE__, send_count);
		#endif

			SendBufferCursor = 0;	//reset send buffer cursor

		return TRUE;
	}
	else
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_reponse_write>::Fail to send data", __LINE__);
		#endif

			SendBufferCursor = 0;	//reset send buffer cursor

		return FALSE;
	}

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqModulator(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: resolve modulator write request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqModulator(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 ctrl_byte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_MODULAOTR_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d:: <mc_response_write_modulator>:: modulator write request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_MODULAOTR_WR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_MODULAOTR_WR_LEN -4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_MODULAOTR_WR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.ModulatorCrc = localCrc;

	/*resolve data and output - 'V'*/
	//filament voltage
	union float_union_t float_union;
	float_union.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];

	m_OutputsModulator.mod_filament_vol = float_union.value;	//output value

	//primary DC voltage
	float_union.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];

	m_OutputsModulator.mod_dc_voltage = float_union.value;	//output value

	//pulse width
	float_union.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];

	m_OutputsModulator.mod_pluse_width = float_union.value;	//output value

	//crc
	uint32_union_t uint32_union;
	uint32_union.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union.value;
	m_OutputsFsm.ParameterCrcRemote.ModulatorCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.ModulatorCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.ModulatorCrcOk = FALSE;

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqGun(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: resolve gun write request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqGun(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 ctrl_byte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_GUN_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_gun>:: gun write request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_GUN_WR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_GUN_WR_LEN-4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_GUN_WR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.GunCrc = localCrc;

	FLOAT float_union[35] = { 0 };	//35
	union float_union_t float_union_temp;

	for (size_t i = 0; i < 35; i++)
	{
		float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];

		float_union[i] = float_union_temp.value;
	}

	/*Gun HV*/
	m_OutputsGun.gun_hv = float_union[0];
	/*Gun Warmup*/
	m_OutputsGun.gun_warmup = float_union[1];
	/*Gun Filament Current Set Tolerance*/
	m_OutputsGun.gun_fila_current_set_tol = float_union[2];
	/*Gun Filament Voltage Min*/
	m_OutputsGun.gun_fila_vol_min = float_union[3];
	/*Gun Filament Voltage Max*/
	m_OutputsGun.gun_fila_vol_max = float_union[4];
	/*Gun Heater Judge Time*/
	m_OutputsGun.gun_heaterok_judgetime = float_union[5];
	/*Gun Cathode Current Min*/
	m_OutputsGun.gun_cathode_current_min = float_union[6];
	/*Gun Cathode Current Max*/
	m_OutputsGun.gun_cathode_current_max = float_union[7];
	/*Gun Dose Rate at Full Power*/
	m_OutputsGun.gun_dr_at_fullpower = float_union[8];
	/*Gun Rundown PRF K*/
	m_OutputsGun.gun_rundown_prf_k = float_union[9];
	/*Gun Rundown Dose Rate K*/
	m_OutputsGun.gun_rundown_dr_k = float_union[10];

	/*Gun HV Set Ratio 1*/
	m_OutputsGun.gun_hv_rat_1 = float_union[11];
	/*Gun HV Set Ratio 2*/
	m_OutputsGun.gun_hv_rat_2 = float_union[12];
	/*Gun HV Set Ratio 3*/
	m_OutputsGun.gun_hv_rat_3 = float_union[13];
	/*Gun HV Set Ratio 4*/
	m_OutputsGun.gun_hv_rat_4 = float_union[14];

	/*Gun Filament Voltage Set Ratio 1*/
	m_OutputsGun.gun_fila_vol_set_rat_1 = float_union[15];
	/*Gun Filament Voltage Set Ratio 2*/
	m_OutputsGun.gun_fila_vol_set_rat_2 = float_union[16];
	/*Gun Filament Voltage Set Ratio 3*/
	m_OutputsGun.gun_fila_vol_set_rat_3 = float_union[17];
	/*Gun Filament Voltage Set Ratio 4*/
	m_OutputsGun.gun_fila_vol_set_rat_4 = float_union[18];

	/*Gun Filament Voltage Ratio 1*/
	m_OutputsGun.gun_fila_vol_rat_1 = float_union[19];
	/*Gun Filament Voltage Ratio 2*/
	m_OutputsGun.gun_fila_vol_rat_2 = float_union[20];
	/*Gun Filament Voltage Ratio 3*/
	m_OutputsGun.gun_fila_vol_rat_3 = float_union[21];
	/*Gun Filament Voltage Ratio 4*/
	m_OutputsGun.gun_fila_vol_rat_4 = float_union[22];

	/*Gun Filament Current Ratio 1*/
	m_OutputsGun.gun_fila_current_rat_1 = float_union[23];
	/*Gun Filament Current Ratio 2*/
	m_OutputsGun.gun_fila_current_rat_2 = float_union[24];
	/*Gun Filament Current Ratio 3*/
	m_OutputsGun.gun_fila_current_rat_3 = float_union[25];
	/*Gun Filament Current Ratio 4*/
	m_OutputsGun.gun_fila_current_rat_4 = float_union[26];

	/*Gun Cathode Current Ratio 1*/
	m_OutputsGun.gun_cathode_current_rat_1 = float_union[27];
	/*Gun Cathode Current Ratio 2*/
	m_OutputsGun.gun_cathode_current_rat_2 = float_union[28];
	/*Gun Cathode Current Ratio 3*/
	m_OutputsGun.gun_cathode_current_rat_3 = float_union[29];
	/*Gun Cathode Current Ratio 4*/
	m_OutputsGun.gun_cathode_current_rat_4 = float_union[30];

	/*Gun HV Read Ratio 1*/
	m_OutputsGun.gun_hv_read_rat1 = float_union[31];
	/*Gun HV Read Ratio 2*/
	m_OutputsGun.gun_hv_read_rat2 = float_union[32];
	/*Gun HV Read Ratio 3*/
	m_OutputsGun.gun_hv_read_rat3 = float_union[33];
	/*Gun HV Read Ratio 4*/
	m_OutputsGun.gun_hv_read_rat4 = float_union[34];

	union uint32_union_t uint32_union_temp;
	/*Gun Warmup Time*/
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];

	m_OutputsGun.gun_warmup_time = uint32_union_temp.value;

	//Crc
	uint32_union_t uint32_union;
	uint32_union.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union.value;
	m_OutputsFsm.ParameterCrcRemote.GunCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.GunCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.GunCrcOk = FALSE;

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqAfc(UCHAR *dequeue_buf, UINT16 *postion)
*
* Describe: resolve afc write response
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqAfc(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_AFC_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_afc>:: afc write request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_AFC_WR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_AFC_WR_LEN - 4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_AFC_WR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.AfcCrc = localCrc;

	union uint32_union_t uint32_union_temp;
	union float_union_t float_union_temp;

	/*afc motor maximum speed*/
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsAfc.afc_motor_max_speed = uint32_union_temp.value;
	/*afc direction swap*/
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsAfc.afc_dir_swap = uint32_union_temp.value;
	/*afc linear low*/
	float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsAfc.afc_linear_low = float_union_temp.value;
	/*afc linear high*/
	float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsAfc.afc_linear_high = float_union_temp.value;
	/*afc preset*/
	float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsAfc.afc_preset = float_union_temp.value;
	/*RF set*/
	float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsAfc.afc_RF_set = float_union_temp.value;

	//Crc
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union_temp.value;
	m_OutputsFsm.ParameterCrcRemote.AfcCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.AfcCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.AfcCrcOk = FALSE;
	

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteAfcCtl(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: resolve afc control write request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqAfcCtl(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_AFC_CTL_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_gun>:: afc ctl write request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_AFC_CTL_WR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_AFC_CTL_WR_LEN - 4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_AFC_CTL_WR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.AfcCtrlCrc = localCrc;

	union uint32_union_t uint32_union_temp;

	/*afc mode set*/
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsAfc.afc_mode_set = uint32_union_temp.value;
	/*afc manual direction*/
	m_OutputsAfc.afc_manual_dir = DequeueBuf[(*Postion)++];
	/*afc manual move*/
	m_OutputsAfc.afc_manual_move = DequeueBuf[(*Postion)++];

	//Crc
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union_temp.value;
	m_OutputsFsm.ParameterCrcRemote.AfcCtrlCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.AfcCtrlCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.AfcCtrlCrcOk = FALSE;

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqDose(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: resolve dose write request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqDose(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 ctrl_byte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_DOSE_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_gun>:: dose write request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_DOSE_WR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_DOSE_WR_LEN - 4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_DOSE_WR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.DoseCrc = localCrc;

	/*dose parameteres set*/
	UINT16 Uint16Array[9] = { 0 };	//8 uint value
	uint16_union_t Uint16Union;
	for (size_t i = 0; i < 9; i++)
	{
		Uint16Union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
		Uint16Union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
		Uint16Array[i] = Uint16Union.value;
	}
	m_OutputsDose.DoseRateCycleTime = Uint16Array[0];
	m_OutputsDose.DoseRateAccTime = Uint16Array[1];
	m_OutputsDose.DoseCalFactorA1 = Uint16Array[2];
	m_OutputsDose.DoseCalFactorB1 = Uint16Array[3];
	m_OutputsDose.DoseCalFactorA2 = Uint16Array[4];
	m_OutputsDose.DoseCalFactorB2 = Uint16Array[5];
	m_OutputsDose.DarkCurrentLimit = Uint16Array[6];
	m_OutputsDose.DummyDoseRateSet = Uint16Array[7];
	m_OutputsDose.DoseInterlockEnable = Uint16Array[8];

	UINT32 Uint32Array[2] = { 0 };	//2 uint32 value
	uint32_union_t Uint32Union;
	for (size_t i = 0; i < 2; i++)
	{
		Uint32Union.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		Uint32Union.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		Uint32Union.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		Uint32Union.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
		Uint32Array[i] = Uint32Union.value;
	}
	m_OutputsDose.SymmetryThreshold1 = Uint32Array[0];
	m_OutputsDose.SymmetryThreshold2 = Uint32Array[1];

	FLOAT FloatArray[6] = { 0 };
	float_union_t FloatUnion;
	for (size_t i = 0; i < 6; i++)
	{
		FloatUnion.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		FloatUnion.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		FloatUnion.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		FloatUnion.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
		FloatArray[i] = FloatUnion.value;
	}
	m_OutputsDose.SymmetryTolerance1 = FloatArray[0];
	m_OutputsDose.SymmetryTolerance2 = FloatArray[1];
	m_OutputsDose.DualChannelRatio = FloatArray[2];
	m_OutputsDose.DualChannelTolerance = FloatArray[3];
	m_OutputsDose.SegmentOverrangeRatio = FloatArray[4];
	m_OutputsDose.DoseRateLimit = FloatArray[5];

	//Crc
	Uint32Union.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = Uint32Union.value;
	m_OutputsFsm.ParameterCrcRemote.DoseCrc= receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.DoseCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.DoseCrcOk = FALSE;

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqBeam(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe:
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqBeam(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_BEAM_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_gun>:: beam write request length error", __LINE__);
		#endif

		return FALSE;
	}

	/*dose parameteres set*/
	float_union_t float_union_temp;
	float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsBeam.beam_total_set1 = float_union_temp.value;

	float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	m_OutputsBeam.beam_total_set2 = float_union_temp.value;

	UINT32 uint32_union[2] = { 0 };	//4 uint32 value
	union uint32_union_t uint32_union_temp;
	for (size_t i = 0; i < 2; i++)
	{
		uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
		uint32_union[i] = uint32_union_temp.value;
	}

	m_OutputsBeam.beam_dose_rate_set = uint32_union[0];
	m_OutputsBeam.beam_time_set = uint32_union[1];

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqCmd(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: ouput gui command to state machine
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqCmd(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_CMD_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_gun>:: gui command request length error", __LINE__);
		#endif

		return FALSE;
	}

	BYTE TempArray[8] = { 0 };

	/*command parameteres set*/
	TempArray[0] = DequeueBuf[(*Postion)++];	//upmachine command byte1
	TempArray[1] = DequeueBuf[(*Postion)++];	//upmachine command byte2
	TempArray[2] = DequeueBuf[(*Postion)++];	//upmachine command byte3
	TempArray[3] = DequeueBuf[(*Postion)++];	//upmachine command byte4
	TempArray[4] = DequeueBuf[(*Postion)++];	//upmachine command byte5
	TempArray[5] = DequeueBuf[(*Postion)++];	//upmachine command byte6
	TempArray[6] = DequeueBuf[(*Postion)++];	//upmachine command byte7
	TempArray[7] = DequeueBuf[(*Postion)++];	//upmachine command byte8

	m_OutputsFsm.GuiCmd1 = TempArray[0];	//upmachine command byte1
	m_OutputsFsm.GuiCmd2 = TempArray[1];	//upmachine command byte2
	m_OutputsFsm.GuiCmd3 = TempArray[2];	//upmachine command byte3
	m_OutputsFsm.GuiCmd4 = TempArray[3];	//upmachine command byte4
	m_OutputsFsm.GuiCmd5 = TempArray[4];	//upmachine command byte5
	m_OutputsFsm.GuiCmd6 = TempArray[5];	//upmachine command byte6
	m_OutputsFsm.GuiCmd7 = TempArray[6];	//upmachine command byte7
	m_OutputsFsm.GuiCmd8 = TempArray[7];	//upmachine command byte8

	for (UINT8 i = 0; i < 8; i++)
	{
		if (TempArray[i] == 0x01)			//command is reset
		{
			m_OutputsFsm.reset_command = TRUE;
			continue;
		}
		else if (TempArray[i] == 0x07)		//command is log out 
		{
			m_OutputsBeam.beam_total_set1 = 0;
			m_OutputsBeam.beam_total_set2 = 0;
			m_OutputsBeam.beam_dose_rate_set = 0;
			m_OutputsBeam.beam_time_set = 0;
		}
		else if (TempArray[i] == 0x0b || TempArray[i] == 0x14)		//command is close patient:0x0b and clean plan:0x14 
		{
			memset(&m_PlanOutputs, 0, sizeof(m_PlanOutputs));
			m_PlanOutputs.PlanReset = TRUE;
		}
		else if (TempArray[i] == 0x09) //continue command
		{
			m_OutputsFsm.reset_command = TRUE; //reset interlock
			continue;
		}
		else
			continue;
	}

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqPrf(UCHAR *dequeue_buf, UINT16 *postion)
*
* Describe: ouput gui command to state machine
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqPrf(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_PRF_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_gun>:: prf write request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_PRF_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_PRF_LEN - 4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_PRF_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.PrfCrc = localCrc;

	union float_union_t float_union_temp[13];
	for (size_t i = 0; i < 13; i++)
	{
		float_union_temp[i].float_byte.lw_high_byte = DequeueBuf[(*Postion)++];	//upmachine prf byte1
		float_union_temp[i].float_byte.lw_low_byte = DequeueBuf[(*Postion)++];	//upmachine prf byte2
		float_union_temp[i].float_byte.hw_high_byte = DequeueBuf[(*Postion)++];	//upmachine prf byte3
		float_union_temp[i].float_byte.hw_low_byte = DequeueBuf[(*Postion)++];	//upmachine prf byte4
	}
	
	//prf set
	m_OutputsPrf.prf_set = float_union_temp[0].value;
	//prf ratio
	m_OutputsPrf.PrfRatio = float_union_temp[1].value;
	//prf delta ratio
	m_OutputsPrf.PrfDeltaRatio = float_union_temp[2].value;
	// prf dpp  unit:MU/Pulse
	m_OutputsPrf.DPP = float_union_temp[3].value;
	// prf 
	m_OutputsPrf.DoseDeltaActionRange= float_union_temp[4].value;
	m_OutputsPrf.PrfCatchCurveD1 = float_union_temp[5].value;
	m_OutputsPrf.PrfCatchCurveR1 = float_union_temp[6].value;
	m_OutputsPrf.PrfCatchCurveD2 = float_union_temp[7].value;
	m_OutputsPrf.PrfCatchCurveR2 = float_union_temp[8].value;
	m_OutputsPrf.PrfCatchCurveP1 = float_union_temp[9].value;
	m_OutputsPrf.PrfCatchCurveQ1 = float_union_temp[10].value;
	m_OutputsPrf.PrfCatchCurveP2 = float_union_temp[11].value;
	m_OutputsPrf.PrfCatchCurveQ2 = float_union_temp[12].value;
	//prf cycle counter
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
	m_OutputsPrf.PrfCatchCycle = uint16_union.value;

	//Crc
	uint32_union_t uint32_union_temp;
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union_temp.value;
	m_OutputsFsm.ParameterCrcRemote.PrfCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.PrfCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.PrfCrcOk = FALSE;
	
	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqCP(UCHAR *dequeue_buf, UINT16 *postion)
*
* Describe: transmit control point
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
UINT8 CTCPServer::ResponseWriteReqCP(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t Uint16Union;
	Uint16Union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	Uint16Union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (Uint16Union.value != MC_UINT_CP_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
		m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_cp>:: cp write request length error", __LINE__);
		#endif

		return FALSE;
	}
	//TCLV - 'V'
	PlanOneCP_t OneCP;
	memset(&OneCP, 0, sizeof(OneCP));	//init

	//get cp index
	UINT16 TargetCP = 0;
	union uint32_union_t Uint32Union;
	Uint32Union.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];

	if (Uint32Union.value > 359)	//check
	{
		#if MC_COM_DEBUG_EXP_WR
		m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_cp>:: cp index invaild:%d", __LINE__, Uint16Union.value > 359);
		#endif

		return FALSE;
	}
	else
	{
		OneCP.CPIndex = Uint32Union.value;			//record cp index
		TargetCP = (UINT16)Uint32Union.value;
		m_PlanOutputs.RecvedCP[TargetCP] = TRUE;
	}
	//get all float data
	FLOAT float_union_array[138] = { 0 };	//138 float value
	union float_union_t float_union;

	for (size_t i = 0; i < 138; i++)
	{
		float_union.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		float_union.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		float_union.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		float_union.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
		float_union_array[i] = float_union.value;
	}

	m_PlanOutputs.BeamEnergyPlan[TargetCP] = float_union_array[0];	//baem energy
	OneCP.BeamEnergy = float_union_array[0];	//record baem energy
	m_PlanOutputs.DoseWeight[TargetCP] = float_union_array[1];	//cumulative meterset weight
	OneCP.DoseWeight = float_union_array[1];	//record baem energy

	for (size_t i = 0; i < 128; i++)
	{
		m_PlanOutputs.MlcPos[TargetCP][i] = float_union_array[i + 2];	//beam limiting device position
		OneCP.MlcPos[i] = float_union_array[i + 2];	//record beam limiting device position
	}

	m_PlanOutputs.MlcAngle[TargetCP] = float_union_array[130];		//beam limiting device angle
	OneCP.MlcAngle = float_union_array[130];		//beam limiting device angle
	m_PlanOutputs.GantryAngle[TargetCP] = float_union_array[131];		//gantry angle
	OneCP.GantryAngle = float_union_array[131];		//gantry angle
	m_PlanOutputs.PssAngle[TargetCP] = float_union_array[132];		//patient support angle
	OneCP.PssAngle = float_union_array[132];		//patient support angle
	m_PlanOutputs.TableVerPos[TargetCP] = float_union_array[133];		//table top vertical position
	OneCP.TableVerPos = float_union_array[133];		//table top vertical position
	m_PlanOutputs.TableLonPos[TargetCP] = float_union_array[134];		//table top longitudinal position
	OneCP.TableLonPos = float_union_array[134];		//table top longitudinal position
	m_PlanOutputs.TableLatPos[TargetCP] = float_union_array[135];		//table top lateral position
	OneCP.TableLatPos = float_union_array[135];		//table top lateral position
	m_PlanOutputs.TablePitchAngle[TargetCP] = float_union_array[136];	//table top pitch angle
	OneCP.TablePitchAngle = float_union_array[136];	//table top pitch angle
	m_PlanOutputs.TableRollAngle[TargetCP] = float_union_array[137];	//table top roll angle
	OneCP.TableRollAngle = float_union_array[137];	//table top roll angle

	m_PlanOutputs.MlcDir[TargetCP] = DequeueBuf[(*Postion)++];				//beam limiting device rotation direction
	m_PlanOutputs.GantryDir[TargetCP] = DequeueBuf[(*Postion)++];			//gantry rotation direction
	m_PlanOutputs.PssDir[TargetCP] = DequeueBuf[(*Postion)++];				//patient support rotation direction
	m_PlanOutputs.TablePitchDir[TargetCP] = DequeueBuf[(*Postion)++];		//table top pitch rotation direction
	m_PlanOutputs.TableRollDir[TargetCP] = DequeueBuf[(*Postion)++];			//table top roll rotation direction

	OneCP.MlcDir = m_PlanOutputs.MlcDir[TargetCP];
	OneCP.GantryDir = m_PlanOutputs.GantryDir[TargetCP];
	OneCP.PssDir = m_PlanOutputs.PssDir[TargetCP];
	OneCP.TablePitchDir = m_PlanOutputs.TablePitchDir[TargetCP];
	OneCP.TableRollDir = m_PlanOutputs.TableRollDir[TargetCP];

	//construct exception
	if (m_PlanExceptionCtrl.CrcErrorEn && TargetCP == 6)
	{
		return EXCEPT_CRC;
	}
	else if (m_PlanExceptionCtrl.MissMiddleEn && TargetCP == m_PlanOutputs.BeamPlan.TotalCP / 2)
	{
		return EXCEPT_MISS_MIDDLE;
	}
	else if (m_PlanExceptionCtrl.MissLastEn && TargetCP == m_PlanOutputs.BeamPlan.TotalCP - 1)
	{
		return EXCEPT_MISS_LAST;
	}
	else
	{
		//go on
	}

	//crc check
	Uint32Union.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];//crc32
	Uint32Union.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	Uint32Union.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];

	UINT32 crc_temp = Crc32.Crc32Buffer((UCHAR *)&OneCP, MC_UINT_CP_WR_LEN - 4);
	if (Uint32Union.value == crc_temp)
	{
		#if MC_COM_DEBUG_EXP_WR
		//m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_cp>::crc32 succeed::crc %x", __LINE__, crc_temp);
		#endif

		return TRUE;
	}
	else
	{
		#if MC_COM_DEBUG_EXP_WR
		m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_cp>::crc32 error::gui crc %x:rtc crc:%x", \
			__LINE__, Uint32Union.value, crc_temp);
		#endif

		return FALSE;
	}
}

/******************************************************************************
* Function: ResponseWriteReqPlanBeam(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: transmit beam data
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
UINT8 CTCPServer::ResponseWriteReqPlanBeam(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 ctrl_byte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_PLANBEAM_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
		m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_planbeam>:: plan beam write request length error:%d", __LINE__, uint16_union.value);
		#endif

		return FALSE;
	}

	//clear shared memory
	m_PlanOutputs.PlanReset = TRUE;
	memset(&m_PlanOutputs.RecvedCP, 0, sizeof(m_PlanOutputs.RecvedCP));

	//store plan data
	m_PlanOutputs.BeamPlan.BeamType = DequeueBuf[(*Postion)++]; //beam type
	m_PlanOutputs.BeamPlan.RadiationType = DequeueBuf[(*Postion)++]; //radiation type

	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
	m_PlanOutputs.BeamPlan.BeamNumber = uint16_union.value; //beam number

	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
	m_PlanOutputs.BeamPlan.TotalCP = uint16_union.value; //total beam


	FLOAT recv_arry[10] = {0};
	union float_union_t float_union;
	for (size_t i = 0; i < 10; i++)
	{
		float_union.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		float_union.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		float_union.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		float_union.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
		recv_arry[i] = float_union.value;
	}
	m_PlanOutputs.BeamPlan.DoseRateSet					= recv_arry[0]; //dose rate set
	m_PlanOutputs.BeamPlan.Dose							= recv_arry[1];	//dose
	m_PlanOutputs.BeamPlan.GantryAngleTolerance			= recv_arry[2];	//gantry angle tolerance
	m_PlanOutputs.BeamPlan.BeamLimitingAngleTolerance	= recv_arry[3]; //beam limiting device angle position tolerance
	m_PlanOutputs.BeamPlan.AsymxPositionTolerance		= recv_arry[4]; //ASYMX Beam Limiting Device Position Tolerance
	m_PlanOutputs.BeamPlan.AsymyPositionTolerance		= recv_arry[5]; //ASYMY Beam Limiting Device Position Tolerance
	m_PlanOutputs.BeamPlan.MlcPositionTolerance			= recv_arry[6];	//MLCX Beam Limiting Device Position Tolerance
	m_PlanOutputs.BeamPlan.TableTopVerPositionTolerance = recv_arry[7]; //Table Top Vertical Position Tolerance
	m_PlanOutputs.BeamPlan.TableTopLonPositionTolerance	= recv_arry[8]; //Table Top Longitudianl Position Tolerance
	m_PlanOutputs.BeamPlan.TableTopLatPositionTolerance	= recv_arry[9]; //Table Top Lateral Position Tolerance

	//Start auto reset counter
	m_AutoResetTimer.ResetTimer();
	m_AutoResetCounter = 0;
	if (m_AutoResetTimer.IsReady())
		m_AutoResetTimer.StartTimer(CurrentSysTime, AUTO_RESET_INTERVAL);

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqEmulator(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: gantry write request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqEmulator(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_EMULATOR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_ctrl_state>:: emualor request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_EMULATOR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_EMULATOR_LEN - 4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_EMULATOR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.EmulatorCrc = localCrc;

	UINT16 PlcEmulatorSet = 0;
	UINT16 ControllerEmuSet = 0;
	/*couch output*/
	//PlcEmulate
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
	PlcEmulatorSet = uint16_union.value;

	m_OutputsHalState.OnGantryRtcEmulate = PlcEmulatorSet & 0x0001 ? TRUE : FALSE;
	m_OutputsHalState.BgmEmulate = PlcEmulatorSet & 0x0002 ? TRUE : FALSE;
	m_OutputsHalState.RgsEmulate = PlcEmulatorSet & 0x0004 ? TRUE : FALSE;
	m_OutputsHalState.BsmEmulate = PlcEmulatorSet & 0x0008 ? TRUE : FALSE;
	m_OutputsHalState.IgsEmulate = PlcEmulatorSet & 0x0010 ? TRUE : FALSE;
	
	//Controller Emulator set
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
	ControllerEmuSet = uint16_union.value;

	m_OutputsHalState.ControllerEmuSet.RgsCtrl = ControllerEmuSet & 0x0004 ? true : false;
	m_OutputsHalState.ControllerEmuSet.BsmCtrl = ControllerEmuSet & 0x0008 ? true : false;
	m_OutputsHalState.ControllerEmuSet.IgsCtrl = ControllerEmuSet & 0x0010 ? true : false;

	//Crc
	uint32_union_t uint32_union_temp;
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union_temp.value;
	m_OutputsFsm.ParameterCrcRemote.EmulatorCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.EmulatorCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.EmulatorCrcOk = FALSE;

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqCtrlState(UCHAR *DequeueBuf, UINT16 *Postion)
*
* Describe: gantry write request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqCtrlState(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UNIT_CTRL_STATE_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_ctrl_state>:: ctrl state request length error", __LINE__);
		#endif

		return FALSE;
	}

	/*couch output*/

	UINT16 uint16_array[3] = { 0 };	//3 uint16 value
	union uint16_union_t uint16_union_temp;

	for (size_t i = 0; i < 3; i++)
	{
		uint16_union_temp.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
		uint16_union_temp.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

		uint16_array[i] = uint16_union_temp.value;
	}

	//m_OutputsCtrlState.ControllerEmulate = uint16_array[0];

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqBsm(UCHAR *dequeue_buf, UINT16 *postion)
*
* Describe: ouput gui command to state machine
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqBsm(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UINT_BSM_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
			m_Trace.Log(tlInfo, "Line:%d::<mc_response_write_gun>:: bsm write request length error", __LINE__);
		#endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UINT_BSM_WR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UINT_BSM_WR_LEN - 4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UINT_BSM_WR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.BsmCrc = localCrc;

	/*bsm set*/	
	m_OutputsBsm.bsm_ok = DequeueBuf[(*Postion)++];	//bsm ok

	FLOAT float_union[5] = { 0 };	//3 float value
	union float_union_t float_union_temp;

	for (size_t i = 0; i < 5; i++)
	{
		float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];

		float_union[i] = float_union_temp.value;
	}

	m_OutputsBsm.bsm_Head_speed = float_union[0];
	m_OutputsBsm.bsm_up_jaw1_speed = float_union[1];
	m_OutputsBsm.bsm_up_jaw2_speed = float_union[2];
	m_OutputsBsm.HeadAngle = float_union[3];
	m_OutputsBsm.HeadAngleOffset = float_union[4];

	UINT16 BsmEnalbe = 0;
	union uint16_union_t uint_union_temp;
	uint_union_temp.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint_union_temp.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
	m_OutputsBsm.BSMEnable=uint_union_temp.value;

	FLOAT CalibrationJaw[16] = { 0 };
	union float_union_t float_union_temp_CalibrationJaw;

	for (size_t i = 0; i < 16; i++)
	{
		float_union_temp_CalibrationJaw.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp_CalibrationJaw.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		float_union_temp_CalibrationJaw.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp_CalibrationJaw.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
		CalibrationJaw[i] = float_union_temp_CalibrationJaw.value;
		m_OutputsBsm.CalibrationJaw[i] = CalibrationJaw[i];
	}

	m_OutputsBsm.BSMInitMode = DequeueBuf[(*Postion)++];

	float	HeadAngleK = 0;
	union float_union_t float_union_temp_HeadAngleK;	

	float_union_temp_HeadAngleK.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp_HeadAngleK.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp_HeadAngleK.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp_HeadAngleK.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	HeadAngleK = float_union_temp_HeadAngleK.value;
	m_OutputsBsm.HeadAngleK = HeadAngleK;

	UINT8 CollimatorPosition;
	CollimatorPosition = DequeueBuf[(*Postion)++];
	m_OutputsBsm.CollimatorPosition = CollimatorPosition;	

	float  HeadAngleSecondaryk = 0;
	union float_union_t float_union_temp_HeadAngleSecondaryK;
	float_union_temp_HeadAngleSecondaryK.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp_HeadAngleSecondaryK.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	float_union_temp_HeadAngleSecondaryK.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	float_union_temp_HeadAngleSecondaryK.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	HeadAngleSecondaryk = float_union_temp_HeadAngleSecondaryK.value;
	m_OutputsBsm.HeadAngleSecondaryK = HeadAngleSecondaryk;

	UINT32 HeadLimitEncoder = 0;
	union uint32_union_t  uint_union_temp_HeadLimitEncoder;
	uint_union_temp_HeadLimitEncoder.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint_union_temp_HeadLimitEncoder.uint32_byte.lw_low_byte  = DequeueBuf[(*Postion)++];
	uint_union_temp_HeadLimitEncoder.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint_union_temp_HeadLimitEncoder.uint32_byte.hw_low_byte  = DequeueBuf[(*Postion)++];
	HeadLimitEncoder = uint_union_temp_HeadLimitEncoder.value;
	m_OutputsBsm.HeadLimitEncoder = HeadLimitEncoder;

	//Crc
	uint32_union_t uint32_union_temp;
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union_temp.value;
	m_OutputsFsm.ParameterCrcRemote.BsmCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.BsmCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.BsmCrcOk = FALSE;

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqVMAT(UCHAR *dequeue_buf, UINT16 *postion)
*
* Describe: VMAT parameters
*
* Input   :
*
* Output  : None
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqVMAT(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UNIT_VMAT_PARA_WR_LEN)
	{
		#if MC_COM_DEBUG_EXP_WR
		m_Trace.Log(tlInfo, "Line:%d::<ResponseWriteReqVMAT>:: VMAT write request length error", __LINE__);
		#endif

		return FALSE;
	}

	FLOAT float_union[20] = { 0 };	//21 float value
	union float_union_t float_union_temp;

	for (size_t i = 0; i < 20; i++)
	{
		float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];

		float_union[i] = float_union_temp.value;
	}

	m_OutputsVMAT.GantryMaxSpeed	= float_union[0];
	m_OutputsVMAT.GantryMinSpeed	= float_union[1];
	m_OutputsVMAT.MlcMaxSpeed		= float_union[2];
	m_OutputsVMAT.MlcMinSpeed		= float_union[3];
	m_OutputsVMAT.HeadMaxSpeed		= float_union[4];
	m_OutputsVMAT.HeadMinSpeed		= float_union[5];
	m_OutputsVMAT.PssMaxSpeed1		= float_union[6];
	m_OutputsVMAT.PssMaxSpeed2		= float_union[7];
	m_OutputsVMAT.PssMaxSpeed3		= float_union[8];
	m_OutputsVMAT.PssMaxSpeed4		= float_union[9];
	m_OutputsVMAT.PssMaxSpeed5		= float_union[10];
	m_OutputsVMAT.PssMaxSpeed6		= float_union[11];
	m_OutputsVMAT.PssMinSpeed1		= float_union[12];
	m_OutputsVMAT.PssMinSpeed2		= float_union[13];
	m_OutputsVMAT.PssMinSpeed3		= float_union[14];
	m_OutputsVMAT.PssMinSpeed4		= float_union[15];
	m_OutputsVMAT.PssMinSpeed5		= float_union[16];
	m_OutputsVMAT.PssMinSpeed6		= float_union[17];
	m_OutputsVMAT.DoseMaxSpeed		= float_union[18];
	m_OutputsVMAT.DoseMinSpeed		= float_union[19];

	return TRUE;
}

/******************************************************************************
* Function: ResponseWriteReqIgs(UCHAR *dequeue_buf, UINT16 *postion)
*
* Describe : VMAT parameters
*
* Input :
*
* Output : None
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqIgs(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UNIT_IGS_WR_LEN)
	{
      #if MC_COM_DEBUG_EXP_WR
		m_Trace.Log(tlInfo, "Line:%d::<ResponseWriteReqVMAT>:: VMAT write request length error", __LINE__);
        #endif

		return FALSE;
	}

	//Crc32 data
	UCHAR crcDataBuf[(MC_UNIT_IGS_WR_LEN - 4)] = { 0 };
	UINT16 crcPosition = *Postion;	//record start position
	for (UINT32 i = 0; i < MC_UNIT_IGS_WR_LEN - 4; i++)
	{
		crcDataBuf[i] = DequeueBuf[crcPosition++];
	}
	UINT32 localCrc = Crc32.Crc32Buffer(crcDataBuf, MC_UNIT_IGS_WR_LEN - 4);
	m_OutputsFsm.ParameterCrcLocal.IgsCrc = localCrc;

	UINT16 Uint16Union[2] = { 0 };	//UINT16 value
	uint16_union_t Uint16UnionTemp;
	for (size_t i = 0; i < 2; i++)
	{
		Uint16UnionTemp.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
		Uint16UnionTemp.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
		Uint16Union[i] = Uint16UnionTemp.value;
	}
	m_OutputsIgs.KVTimeOut = Uint16Union[0];
	m_OutputsIgs.MVTimeOut = Uint16Union[1];



	INT32 Int32Union[4] = { 0 };	//INT32 value
	int32_union_t Int32UnionTemp;
	for (size_t i = 0; i < 4; i++)
	{
		Int32UnionTemp.int32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		Int32UnionTemp.int32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		Int32UnionTemp.int32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		Int32UnionTemp.int32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
		Int32Union[i] = Int32UnionTemp.value;
	}
	m_OutputsIgs.KVOffset1 = Int32Union[0];
	m_OutputsIgs.KVOffset2 = Int32Union[1];
	m_OutputsIgs.MVOffset1 = Int32Union[2];
	m_OutputsIgs.MVOffset2 = Int32Union[3];

	FLOAT float_union[6] = { 0 };	// float value
	union float_union_t float_union_temp;

	for (size_t i = 0; i < 6; i++)
	{
		float_union_temp.float_byte.lw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.lw_low_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_high_byte = DequeueBuf[(*Postion)++];
		float_union_temp.float_byte.hw_low_byte = DequeueBuf[(*Postion)++];

		float_union[i] = float_union_temp.value;
	}
	m_OutputsIgs.KvWorkPosH = float_union[0];
	m_OutputsIgs.KvWorkPosF = float_union[1];
	m_OutputsIgs.MvWorkPosX = float_union[2];
	m_OutputsIgs.MvWorkPosY = float_union[3];
	m_OutputsIgs.KvTorlerance = float_union[4];
	m_OutputsIgs.MvTorlerance = float_union[5];

	//Crc
	uint32_union_t uint32_union_temp;
	uint32_union_temp.uint32_byte.lw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.lw_low_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_high_byte = DequeueBuf[(*Postion)++];
	uint32_union_temp.uint32_byte.hw_low_byte = DequeueBuf[(*Postion)++];
	UINT32 receivedCrc = uint32_union_temp.value;
	m_OutputsFsm.ParameterCrcRemote.IgsCrc = receivedCrc;

	//Check crc
	if (localCrc == receivedCrc)
		m_OutputsFsm.ParaCrcStatus.IgsCrcOk = TRUE;
	else
		m_OutputsFsm.ParaCrcStatus.IgsCrcOk = FALSE;

	return TRUE;
}
/******************************************************************************
* Function: ResponseWriteReqIgsIcu(UCHAR *dequeue_buf, UINT16 *postion)
*
* Describe : VMAT parameters
*
* Input :
*
* Output : None
*******************************************************************************/
BOOL CTCPServer::ResponseWriteReqIgsIcu(UCHAR *DequeueBuf, UINT16 *Postion)
{
	/*input parameters availability check*/
	//check TCLV - 'C'
	UINT8 CtrlByte = DequeueBuf[(*Postion)++];
	//check TCLV - 'L'
	uint16_union_t uint16_union;
	uint16_union.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
	uint16_union.uint16_byte.low_byte = DequeueBuf[(*Postion)++];

	if (uint16_union.value != MC_UNIT_IGSICU_WR_LEN)
	{
    #if MC_COM_DEBUG_EXP_WR
		m_Trace.Log(tlInfo, "Line:%d::<ResponseWriteReqVMAT>:: VMAT write request length error", __LINE__);
    #endif

		return FALSE;
	}
	m_OutputsIgs.SynchronousSequence = DequeueBuf[(*Postion)++];
	m_OutputsIgs.WorkMode = DequeueBuf[(*Postion)++];
	m_OutputsIgs.FullHalfShape = DequeueBuf[(*Postion)++];
	m_OutputsIgs.Protocal = DequeueBuf[(*Postion)++];
	m_OutputsIgs.IcuFocusExp = DequeueBuf[(*Postion)++];
	m_OutputsIgs.IcuFrequencyExp = DequeueBuf[(*Postion)++];
	m_OutputsIgs.IcuKVExp = DequeueBuf[(*Postion)++];


	UINT16 Uint16Union[2] = { 0 };	//UINT16 value
	uint16_union_t Uint16UnionTemp;
	for (size_t i = 0; i < 2; i++)
	{
		Uint16UnionTemp.uint16_byte.high_byte = DequeueBuf[(*Postion)++];
		Uint16UnionTemp.uint16_byte.low_byte = DequeueBuf[(*Postion)++];
		Uint16Union[i] = Uint16UnionTemp.value;
	}
	m_OutputsIgs.IcuMAExp = Uint16Union[0];
	m_OutputsIgs.IcuMSExp = Uint16Union[1];

	INT16 Int16Union[4] = { 0 };	//INT16 value
	int16_union_t Int16UnionTemp;
	for (size_t i = 0; i < 4; i++)
	{
		Int16UnionTemp.int16_byte.high_byte = DequeueBuf[(*Postion)++];
		Int16UnionTemp.int16_byte.low_byte = DequeueBuf[(*Postion)++];
		Int16Union[i] = Int16UnionTemp.value;
	}
	m_OutputsIgs.CollimatorCross = Int16Union[0];
	m_OutputsIgs.CollimatorLong = Int16Union[1];
	m_OutputsIgs.CollimatorOffsetCross = Int16Union[2];
	m_OutputsIgs.CollimatorOffsetLong = Int16Union[3];

	return TRUE;
}

/******************************************************************************
* Function: get_cur_sys_time(VOID)
*
* Describe: get current system time
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::GetCurSysTime(ITcTask* ipTask)
{
	/*update system time*/
	ipTask->GetCurrentSysTime(&CurrentSysTime);	//get current sys time

	TcFileTimeToSystemTime(CurrentSysTime, &FormatSysTime);
	//format_sys_time.wHour += 8;						//convert to UTC+8

	CurrentSysTime /= 10000;						//convert to uint ms

	return TRUE;
}

/******************************************************************************
* Function: ResetModuleOutput(VOID)
*
* Describe: reset module outputs example gui command..
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResetModuleOutput(VOID)
{
	/*auto reset gui command*/
	if ((CycleCounter++) == MC_AUTO_RESET_TIME)						//command hold time : 50*10ms = 500ms
	{
		//mc_response_cmd_reset();
		m_OutputsFsm.GuiCmd1 = 0;
		m_OutputsFsm.GuiCmd2 = 0;
		m_OutputsFsm.GuiCmd3 = 0;
		m_OutputsFsm.GuiCmd4 = 0;
		m_OutputsFsm.GuiCmd5 = 0;
		m_OutputsFsm.GuiCmd6 = 0;
		m_OutputsFsm.GuiCmd7 = 0;
		m_OutputsFsm.GuiCmd8 = 0;

		m_PlanOutputs.PlanReset = FALSE;
		m_OutputsFsm.reset_command = FALSE;

		CycleCounter = 0;							//reset counter

		/*if (!m_OutputsFsm.ComStateGUI)
		{
			m_OutputsBeam.beam_total_set1 = 0;
			m_OutputsBeam.beam_total_set2 = 0;
			m_OutputsBeam.beam_dose_rate_set = 0;
			m_OutputsBeam.beam_time_set = 0;
		}
		else
		{
			//do nothing
		}*/
	}

	m_OutputsBeam.beam_time_set = 10;

	/*Auto reset*/
	if (m_AutoResetTimer.IsTimeOut(CurrentSysTime))
	{
		m_OutputsFsm.reset_command = !m_OutputsFsm.reset_command;	//toggle reset command
		m_AutoResetCounter++;
		m_AutoResetTimer.ResetTimer();
		if (m_AutoResetTimer.IsReady())
			m_AutoResetTimer.StartTimer(CurrentSysTime, AUTO_RESET_INTERVAL);
	}
	else if (AUTO_RESET_NUMBER <= m_AutoResetCounter)
	{
		m_AutoResetTimer.ResetTimer();
		m_AutoResetCounter = 0;
	}
	else
	{
		//do nothing
	}
		
	return TRUE;
}

/******************************************************************************
* Function: ListenSocket(VOID))
*
* Describe: listen socket to wait client connect
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ListenSocket(VOID)
{
	HRESULT hr = S_OK;

	/*auto reset gui command*/
	if (m_SockId == 0)
	{
		SequenceNum = 1;							//reset real time packet sequence
		m_OutputsFsm.ComStateGUI = FALSE;			//not connectted

		/*listen socket*/
		if (SUCCEEDED_DBG(hr = m_spTcpProt->AllocSocket(THIS_CAST(ITcIoTcpProtocolRecv), m_SockId)))
		{
			if (FAILED(hr = m_spTcpProt->Listen(m_SockId, m_TcpServerPort)))
			{
				m_spTcpProt->FreeSocket(m_SockId);

				#if MC_COM_DEBUG_COM_TRACE
				m_Trace.Log(tlInfo, "Line:%d::<CycleUpdate>::Server Listen failed::socket:%d", __LINE__, m_SockId);
				#endif

				return FALSE;	//new cycle
			}
			else
			{
				#if MC_COM_DEBUG_COM_TRACE
				m_Trace.Log(tlInfo, "Line:%d::<CycleUpdate>::Server Listen succeed::socket:%d", __LINE__, m_SockId);
				#endif

				return FALSE;	//new cycle
			}

		}
		else
		{
			#if MC_COM_DEBUG_COM_TRACE
			m_Trace.Log(tlInfo, "Line:%d::<CycleUpdate>::Alloc socket failed", __LINE__);
			#endif

			return FALSE;	//new cycle
		}
	}
	else
	{
		return TRUE;	//client connected
	}
}

/******************************************************************************
* Function: ResponseRequest(VOID)
*
* Describe: response client request
*
* Input   :
*
* Output  : None
*
* Return  : TRUE or FALSE
*
* Others  :
*******************************************************************************/
BOOL CTCPServer::ResponseRequest(VOID)
{
	//client connected
	if (0 != ClientSocket)
	{
		m_OutputsFsm.ComStateGUI = TRUE;		//connectted

		//check socket send buffer
		ULONG num;
		m_spTcpProt->GetFreeSendDataSize(ClientSocket, num);
		if (num != 16192)						//have not send data
		{
			return FALSE;						//new cycle for waiting
		}

		//reponse gui request
		ResponseGuiRequest();

		return TRUE;
	}
	else
	{
		m_OutputsFsm.ComStateGUI = FALSE;		//not connectted
		
		return FALSE;
	}
}

